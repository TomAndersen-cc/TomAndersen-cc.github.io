<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eden</title>
  
  <subtitle>Get busy living, or get busy dying</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tomandersen-cc.github.io/"/>
  <updated>2020-06-25T01:53:44.246Z</updated>
  <id>https://tomandersen-cc.github.io/</id>
  
  <author>
    <name>Tom Andersen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kafka之Kafka Streams使用练习</title>
    <link href="https://tomandersen-cc.github.io/2020/04/23/Kafka%E4%B9%8BKafka%20Streams%E4%BD%BF%E7%94%A8%E7%BB%83%E4%B9%A0/"/>
    <id>https://tomandersen-cc.github.io/2020/04/23/Kafka%E4%B9%8BKafka%20Streams%E4%BD%BF%E7%94%A8%E7%BB%83%E4%B9%A0/</id>
    <published>2020-04-23T01:53:00.000Z</published>
    <updated>2020-06-25T01:53:44.246Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>kafka版本：2.11-2.1.1</li><li>主要练习的功能是：在某个生产者向first主题中生产消息时，同时通过KafkaStreams将生产消息作特定处理后输出到主题second中</li></ul><a id="more"></a><h2 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.kafka/kafka-clients --&gt;</span><br><span class="hljs-comment">&lt;!-- Kafka客户端API --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka-clients<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.kafka/kafka --&gt;</span><br><span class="hljs-comment">&lt;!-- Kafka核心API --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka_2.11<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--声明KafkaStreams依赖包--&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.kafka/kafka-streams --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka-streams<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="KafkaSteamsDemo-java："><a href="#KafkaSteamsDemo-java：" class="headerlink" title="KafkaSteamsDemo.java："></a>KafkaSteamsDemo.java：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * &lt;p&gt;本类主要用于演示&#123;<span class="hljs-doctag">@link</span> KafkaStreams&#125;的使用方法,同时也是练习.<br> * KafkaStreams所需配置信息可查看&#123;<span class="hljs-doctag">@link</span> StreamsConfig&#125;.<br> * (已测试)<br> *<br> * <span class="hljs-doctag">@author</span> TomAndersen<br> * <span class="hljs-doctag">@version</span> 1.0<br> * <span class="hljs-doctag">@date</span> 2020/3/19<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaSteamsDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 1.配置相关参数</span><br>        Properties props = <span class="hljs-keyword">new</span> Properties();<br>        <span class="hljs-comment">// 设置Application ID</span><br>        props.put(StreamsConfig.APPLICATION_ID_CONFIG, <span class="hljs-string">"KafkaStreamsDemo"</span>);<br>        <span class="hljs-comment">// 设置Brokers集群</span><br>        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="hljs-string">"hadoop101:9092,hadoop102:9092,hadoop103:9092"</span>);<br>        <span class="hljs-comment">// 设置Key和Value的序列化/反序列化器</span><br>        <span class="hljs-comment">/*props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());<br>        props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());*/</span><br>        <span class="hljs-comment">// 定义Stream的数据源和数据池Topic</span><br>        String streamSourceTopic = <span class="hljs-string">"first"</span>;<br>        String streamSinkTopic = <span class="hljs-string">"second"</span>;<br><br>        <span class="hljs-comment">// 2.创建StreamsBuilder实例</span><br>        StreamsBuilder streamsBuilder = <span class="hljs-keyword">new</span> StreamsBuilder();<br><br>        <span class="hljs-comment">// 3.创建并配置Streams拓扑结构</span><br>        Topology topology = streamsBuilder.build()<br>                .addSource(<span class="hljs-string">"StreamSource"</span>, streamSourceTopic)<br>                .addProcessor(<span class="hljs-string">"StreamProcessor"</span>, <span class="hljs-keyword">new</span> ProcessorSupplier&lt;<span class="hljs-keyword">byte</span>[], <span class="hljs-keyword">byte</span>[]&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> Processor&lt;<span class="hljs-keyword">byte</span>[], <span class="hljs-keyword">byte</span>[]&gt; get() &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LogProcessor();<br>                    &#125;<br>                &#125;, <span class="hljs-string">"StreamSource"</span>)<br>                .addSink(<span class="hljs-string">"StreamSink"</span>, streamSinkTopic, <span class="hljs-string">"StreamProcessor"</span>);<br><br>        <span class="hljs-comment">// 4.创建KafkaStreams实例</span><br>        KafkaStreams kafkaStreams = <span class="hljs-keyword">new</span> KafkaStreams(topology, props);<br><br>        <span class="hljs-comment">// 5.启动KafkaStreams</span><br>        kafkaStreams.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LogProcessor-java："><a href="#LogProcessor-java：" class="headerlink" title="LogProcessor.java："></a>LogProcessor.java：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">/**<br> * 此类主要用于为KafkaStreams实现中间的处理过程.<br> * (已测试)<br> * @author TomAndersen<br> * @version 1.0<br> * @date 2020/3/20<br> */<br>public class LogProcessor implements Processor&lt;byte[], byte[]&gt; &#123;<br>    // 定义配置信息<br>    private ProcessorContext context;<br><br>    // 初始化获取配置信息<br>    @Override<br>    public void init(ProcessorContext context) &#123;<br>        this.context = context;<br>    &#125;<br><br>    // 正式的处理逻辑<br>    // 本次实现的主要处理功能是将value中的"&gt;&gt;&gt;"标记清除<br>    @Override<br>    public void process(byte[] key, byte[] value) &#123;<br><br>        // 将输入的字节数组转化成String对象<br>        String inputValue = new String(value);<br>        // 清除字符串中的指定字符<br>        inputValue = inputValue.replaceAll("&gt;&gt;&gt;", "");<br>        // 将处理后的&lt;Key Value&gt;输出到上下文对象Context中,之后会传输给下一个Topic<br>        context.forward(key, inputValue.getBytes());<br><br>    &#125;<br><br>    // 释放相关资源<br>    @Override<br>    public void close() &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;kafka版本：2.11-2.1.1&lt;/li&gt;
&lt;li&gt;主要练习的功能是：在某个生产者向first主题中生产消息时，同时通过KafkaStreams将生产消息作特定处理后输出到主题second中&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="https://tomandersen-cc.github.io/categories/Kafka/"/>
    
    
      <category term="Linux" scheme="https://tomandersen-cc.github.io/tags/Linux/"/>
    
      <category term="Kafka" scheme="https://tomandersen-cc.github.io/tags/Kafka/"/>
    
      <category term="Shell" scheme="https://tomandersen-cc.github.io/tags/Shell/"/>
    
      <category term="Kafka Stream" scheme="https://tomandersen-cc.github.io/tags/Kafka-Stream/"/>
    
  </entry>
  
  <entry>
    <title>Kafka之集群压力测试</title>
    <link href="https://tomandersen-cc.github.io/2020/03/23/Kafka%E4%B9%8B%E9%9B%86%E7%BE%A4%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
    <id>https://tomandersen-cc.github.io/2020/03/23/Kafka%E4%B9%8B%E9%9B%86%E7%BE%A4%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</id>
    <published>2020-03-23T07:21:37.000Z</published>
    <updated>2020-04-18T07:55:36.546Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kafka官方在安装包的bin目录下提供了<code>kafka-producer-perf-test.sh</code>和<code>kafka-consumer-perf-test.sh</code>两个压力测试脚本，分别用于测试生产者和消费者的性能。通过Kafka压力测试脚本，能够得知Kafka集群的性能瓶颈所在（CPU/内存/网络带宽）等，在通常情况下Kafka集群的性能瓶颈是网络带宽</p><a id="more"></a><h2 id="1）Kafka-Producer压力测试"><a href="#1）Kafka-Producer压力测试" class="headerlink" title="1）Kafka Producer压力测试"></a>1）Kafka Producer压力测试</h2><h3 id="测试命令："><a href="#测试命令：" class="headerlink" title="测试命令："></a>测试命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kafka-producer-perf-test.sh  --topic <span class="hljs-built_in">test</span> --record-size 100 --num-records 100000 --throughput 1000 --producer-props bootstrap.servers=hadoop101:9092,hadoop102:9092,hadoop103:9092<br></code></pre></td></tr></table></figure><h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><p><code>topic</code>指定消息存放的topic，<code>record-size</code>是一条信息有多大（单位是Byte），<code>num-records</code>是总共发送多少条信息，<code>throughput</code>是每秒多少条信息</p><h3 id="测试结果示例："><a href="#测试结果示例：" class="headerlink" title="测试结果示例："></a>测试结果示例：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">5000 records sent, 999.4 records/sec (0.10 MB/sec), 1.9 ms avg latency, 254.0 max latency.<br>5002 records sent, 1000.4 records/sec (0.10 MB/sec), 0.7 ms avg latency, 12.0 max latency.<br>5001 records sent, 1000.0 records/sec (0.10 MB/sec), 0.8 ms avg latency, 4.0 max latency.<br>5000 records sent, 1000.0 records/sec (0.10 MB/sec), 0.7 ms avg latency, 3.0 max latency.<br>5000 records sent, 1000.0 records/sec (0.10 MB/sec), 0.8 ms avg latency, 5.0 max latency.<br></code></pre></td></tr></table></figure><h3 id="测试结果解析："><a href="#测试结果解析：" class="headerlink" title="测试结果解析："></a>测试结果解析：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">5000 records sent, 999.4 records/sec (0.10 MB/sec), 1.9 ms avg latency, 254.0 max latency.<br></code></pre></td></tr></table></figure><p><strong>发送记录数</strong>5000条，<strong>每秒发送记录数</strong>999.4条，<strong>每秒发送数据量</strong>0.1MB，<strong>平均每条记录延迟</strong>1.9ms，<strong>最大延迟</strong>254.0ms</p><h2 id="2）Kafka-Consumer压力测试"><a href="#2）Kafka-Consumer压力测试" class="headerlink" title="2）Kafka Consumer压力测试"></a>2）Kafka Consumer压力测试</h2><h3 id="测试命令：-1"><a href="#测试命令：-1" class="headerlink" title="测试命令："></a>测试命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kafka-consumer-perf-test.sh --zookeeper zkServer1:2181 --topic <span class="hljs-built_in">test</span> --fetch-size 10000 --messages 10000000 --threads 1<br></code></pre></td></tr></table></figure><h3 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h3><p><code>zookeeper</code>指定zookeeper集群，<code>topic</code>指定消费的topic，<code>fetch-size</code>指定每次取出的数据大小（单位为Byte）<code>messages</code>总共消费的消息个数</p><h3 id="测试结果示例：-1"><a href="#测试结果示例：-1" class="headerlink" title="测试结果示例："></a>测试结果示例：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">start.time, end.time, data.consumed.in.MB, MB.sec, data.consumed.in.nMsg, nMsg.sec<br>2019-02-19 20:29:07:566, 2019-02-19 20:29:12:170, 9.5368, 2.0714, 100010, 21722.4153<br></code></pre></td></tr></table></figure><h3 id="测试结果解析：-1"><a href="#测试结果解析：-1" class="headerlink" title="测试结果解析："></a>测试结果解析：</h3><p><strong>本次消费开始时间，本次消费结束时间，消费数据量</strong>9.5368MB，<strong>平均每秒吞吐</strong>2.0714MB/s，<strong>消费记录数</strong>100010条，<strong>平均每秒消费</strong>21722.4153条</p><h2 id="3）Kafka集群集群数量计算（仅供参考）"><a href="#3）Kafka集群集群数量计算（仅供参考）" class="headerlink" title="3）Kafka集群集群数量计算（仅供参考）"></a>3）Kafka集群集群数量计算（仅供参考）</h2><h3 id="经验公式："><a href="#经验公式：" class="headerlink" title="经验公式："></a>经验公式：</h3><p><strong>Kafka集群主机数=2*（峰值生产速度*副本数/单机写入速度/10）+1</strong></p><h3 id="计算方式："><a href="#计算方式：" class="headerlink" title="计算方式："></a>计算方式：</h3><p>先要预估一天内数据生产速率的峰值，然后用Kafka自带的生产压测（只测试Kafka的写入速度，保证数据不积压）求得Kafka单机的写入速度，再根据设定的副本数，就能预估出需要部署Kafka的数量。</p><h3 id="计算示例："><a href="#计算示例：" class="headerlink" title="计算示例："></a>计算示例：</h3><p>比如我们采用压力测试测出写入的速度是10M/s一台，峰值的业务数据的生产速度是50M/s，副本数为2，则计算过程为：机器数量=2*（50*2/100）+ 1=3台</p><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Kafka官方在安装包的bin目录下提供了&lt;code&gt;kafka-producer-perf-test.sh&lt;/code&gt;和&lt;code&gt;kafka-consumer-perf-test.sh&lt;/code&gt;两个压力测试脚本，分别用于测试生产者和消费者的性能。通过Kafka压力测试脚本，能够得知Kafka集群的性能瓶颈所在（CPU/内存/网络带宽）等，在通常情况下Kafka集群的性能瓶颈是网络带宽&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="https://tomandersen-cc.github.io/categories/Kafka/"/>
    
    
      <category term="Linux" scheme="https://tomandersen-cc.github.io/tags/Linux/"/>
    
      <category term="Kafka" scheme="https://tomandersen-cc.github.io/tags/Kafka/"/>
    
      <category term="Shell" scheme="https://tomandersen-cc.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之NexT主题实现点击按钮滚动到指定位置</title>
    <link href="https://tomandersen-cc.github.io/2020/03/23/Hexo%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%8A%A8%E6%89%93%E5%AD%97%E5%8A%A8%E7%94%BB/"/>
    <id>https://tomandersen-cc.github.io/2020/03/23/Hexo%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%8A%A8%E6%89%93%E5%AD%97%E5%8A%A8%E7%94%BB/</id>
    <published>2020-03-23T07:20:21.000Z</published>
    <updated>2020-03-23T07:30:47.399Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本次主要实现的功能是指定组件插入特定文本，并以打字的方式出现。主要是通过使用JavaScript插件<code>typed</code>和<code>jquery</code>实现</li><li>使用本教程之前记得先将博客备份，以免出现不可逆损失</li><li>Hexo版本：4.2.0</li><li>NexT版本：7.7.1</li><li>typed版本：2.0.4</li></ul><a id="more"></a><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="1）下载插件"><a href="#1）下载插件" class="headerlink" title="1）下载插件"></a>1）下载插件</h3><p>本次使用的<code>typed</code>插件下载地址：<a href="https://cdn.bootcss.com/typed.js/2.0.5/typed.js" target="_blank" rel="noopener">https://cdn.bootcss.com/typed.js/2.0.5/typed.js</a>，<code>jquery</code>插件下载地址：<a href="https://wow.techbrood.com/libs/jquery/jquery.min.js" target="_blank" rel="noopener">https://wow.techbrood.com/libs/jquery/jquery.min.js</a></p><p>在使用浏览器下载时，可以通过Ctrl+s组合键将其保存为.js文件</p><p>下载完成之后将此插件放入Hexo根目录的<code>source</code>文件夹的某个路径下，为了便于引用，我直接存放在<code>source</code>文件夹下</p><h3 id="2）创建swig文件"><a href="#2）创建swig文件" class="headerlink" title="2）创建swig文件"></a>2）创建swig文件</h3><p><strong>typewriter.swig</strong>：先在Hexo根目录的<code>themes\next\layout</code>路径下创建<code>.swig</code>文件，此文件主要用于存放将要加入index.html页面中的代码。本次创建的文件名为<code>typewriter.swig</code>，其中代码主要为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"typed.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><br>   <span class="hljs-keyword">var</span> typed = <span class="hljs-keyword">new</span> Typed(<span class="hljs-string">'.typewriter-content'</span>,&#123;<br>      <span class="hljs-comment">// 注意：输出的可以是标签,将标签当节点运行.比如下面的h1</span><br>  <span class="hljs-comment">// 这是一个字符串数组,可以填充多个值,使用引号修饰,使用逗号分割</span><br>      <span class="hljs-attr">strings</span>: [<span class="hljs-string">'&lt;h1&gt;&#123;&#123; subtitle &#125;&#125;&lt;h1&gt;'</span>],<br>  <span class="hljs-comment">// 速度值越小打字速度越快</span><br>      <span class="hljs-attr">typeSpeed</span>:<span class="hljs-number">80</span>,<br>  <span class="hljs-comment">// 用于在在输出字符结尾闪烁的符号</span><br>  <span class="hljs-attr">cursorChar</span>: <span class="hljs-string">'_'</span><br>   &#125;);<br>   <span class="hljs-comment">// 设置页面加载完成时再开始打字</span><br>   typed.stop();<br>    $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      typed.start();<br>    &#125;);<br></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>参数介绍</strong>：<code>typewriter-content</code>是需要插入打字动画的组件的class名，<code>{{subtitle}}</code>指的是Hexo根目录<code>_config.yml</code>文件中自定义设置的subtitle变量即副标题，此参数可以直接手动设置成其他字符串</p><p><strong>也可以使用下载地址的方式引入插件，如</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">script src=<span class="hljs-string">"//wow.techbrood.com/libs/jquery/jquery.min.js"</span>&gt;&lt;/script&gt;<br>&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/javascript"</span> src=<span class="hljs-string">"https://cdn.bootcss.com/typed.js/2.0.5/typed.js"</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>可以在浏览器中使用开发者模式（F12）来查看各个组件的class ID，如：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;div class=<span class="hljs-string">"typewriter-container"</span>&gt;<br>&lt;div class=<span class="hljs-string">"typewriter"</span>&gt;<br>&lt;span class=<span class="hljs-string">"typewriter-content"</span>&gt;&lt;/span&gt;<br>&lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><h3 id="3）引入自定义的swig文件"><a href="#3）引入自定义的swig文件" class="headerlink" title="3）引入自定义的swig文件"></a>3）引入自定义的swig文件</h3><p>在Hexo根目录的<code>themes\next\layout</code>路径下找到<code>index.swig</code>文件，此文件专门用于控制生成的index.html文件内容，遵循swig语法。在其中合适空行加入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<span class="hljs-comment"># 在index.html页面加入打字动画特效 #&#125;</span><br>&#123;% include <span class="hljs-string">'typewriter.swig'</span> %&#125;<br></code></pre></td></tr></table></figure><h3 id="4）设置CSS样式"><a href="#4）设置CSS样式" class="headerlink" title="4）设置CSS样式"></a>4）设置CSS样式</h3><p>在NexT主题目录下的<code>_config.yml</code>文件中的<code>custom_file_path</code>下通过设置<code>style</code>参数来指定自定义CSS样式文件的路径，此文件中的样式设置会覆盖之前默认样式参数</p><p>默认路径为Hexo根目录下的<code>source\_data\styles.styl</code>，此文件需要自行创建</p><p>可以通过插入以下代码来设置打字效果中<strong>游标</strong>的CSS样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 如果光标没出现，而是出现在下一行，那么就是盒子是块级标签，必须得转换成行内标签 */</span><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">3rem</span><span class="hljs-meta">!important</span>;<br>&#125;<br><span class="hljs-comment">/* 想让的光标闪动的话，复制下面的代码 */</span><br><span class="hljs-selector-class">.typed-cursor</span>&#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">3rem</span><span class="hljs-meta">!important</span>;<br>  <span class="hljs-attribute">animation</span>: typedjsBlink <span class="hljs-number">1s</span> infinite;<br>  <span class="hljs-attribute">-webkit-animation</span>: typedjsBlink <span class="hljs-number">1s</span> infinite;<br>&#125;<br><span class="hljs-keyword">@keyframes</span> typedjsBlink&#123;<br>  50% &#123; <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.0</span>; &#125;<br>&#125;<br><span class="hljs-keyword">@-webkit-keyframes</span> typedjsBlink&#123;<br>  0% &#123; <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>; &#125;<br>  50% &#123; <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.0</span>; &#125;<br>  100% &#123; <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>; &#125;<br>&#125;<br><span class="hljs-selector-class">.typed-fade-out</span>&#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">transition</span>: opacity .<span class="hljs-number">25s</span>;<br>  <span class="hljs-attribute">-webkit-animation</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">animation</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5）重新生成博客"><a href="#5）重新生成博客" class="headerlink" title="5）重新生成博客"></a>5）重新生成博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本次主要实现的功能是指定组件插入特定文本，并以打字的方式出现。主要是通过使用JavaScript插件&lt;code&gt;typed&lt;/code&gt;和&lt;code&gt;jquery&lt;/code&gt;实现&lt;/li&gt;
&lt;li&gt;使用本教程之前记得先将博客备份，以免出现不可逆损失&lt;/li&gt;
&lt;li&gt;Hexo版本：4.2.0&lt;/li&gt;
&lt;li&gt;NexT版本：7.7.1&lt;/li&gt;
&lt;li&gt;typed版本：2.0.4&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="个人博客搭建" scheme="https://tomandersen-cc.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Hexo" scheme="https://tomandersen-cc.github.io/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://tomandersen-cc.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之NexT主题实现点击按钮滚动到指定位置</title>
    <link href="https://tomandersen-cc.github.io/2020/03/23/Hexo%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%BB%9A%E5%8A%A8%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE/"/>
    <id>https://tomandersen-cc.github.io/2020/03/23/Hexo%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%BB%9A%E5%8A%A8%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE/</id>
    <published>2020-03-23T07:20:21.000Z</published>
    <updated>2020-03-23T07:30:27.002Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本次主要实现的功能是，点击index页面中的标题或者其他组件，页面会自动向下滚动至文章版块。主要使用JavaScript插件<code>jquery</code>实现</li><li>使用本教程之前记得先将博客备份，以免出现不可逆损失</li><li>Hexo版本：4.2.0</li><li>NexT版本：7.7.1</li><li>jquery版本：1.11.1</li></ul><a id="more"></a><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="1）下载jquery插件"><a href="#1）下载jquery插件" class="headerlink" title="1）下载jquery插件"></a>1）下载jquery插件</h3><p>本次使用的<code>jquery</code>插件下载地址：<a href="https://wow.techbrood.com/libs/jquery/jquery.min.js" target="_blank" rel="noopener">https://wow.techbrood.com/libs/jquery/jquery.min.js</a></p><p>在使用浏览器下载时，可以通过Ctrl+s组合键将其保存为.js文件</p><p>下载完成之后将此插件放入Hexo根目录的<code>source</code>文件夹的某个路径下，为了便于引用，我直接存放在<code>source</code>文件夹下</p><h3 id="2）创建swig文件"><a href="#2）创建swig文件" class="headerlink" title="2）创建swig文件"></a>2）创建swig文件</h3><p><strong>custom.swig</strong>：先在Hexo根目录的<code>themes\next\layout</code>路径下创建<code>.swig</code>文件，此文件主要用于存放将要加入index.html页面中的代码。本次创建的文件名为<code>custom.swig</code>，其中代码主要为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><br>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>$(<span class="hljs-string">".typewriter-content"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>$(<span class="hljs-string">'html, body'</span>).animate(&#123;<br><span class="hljs-attr">scrollTop</span>: $(<span class="hljs-string">".posts-expand"</span>).offset().top<br>&#125;, <span class="hljs-number">500</span>);<br>&#125;);<br>&#125;);<br></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以使用下载地址的方式引入插件，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//wow.techbrood.com/libs/jquery/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>参数介绍</strong>：其中<code>typewriter-content</code>是需要实现点击功能组件的class ID，<code>posts-expand</code>是需要滚动至的组件的class ID</p><p><strong>可以在浏览器中使用开发者模式（F12）来查看各个组件的class ID，如：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"typewriter-container"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"typewriter"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"typewriter-content"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3）引入自定义的swig文件"><a href="#3）引入自定义的swig文件" class="headerlink" title="3）引入自定义的swig文件"></a>3）引入自定义的swig文件</h3><p>在Hexo根目录的<code>themes\next\layout</code>路径下找到<code>index.swig</code>文件，此文件专门用于控制生成的index.html文件内容，遵循swig语法。在其中合适空行加入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<span class="hljs-comment"># 在index.html页面的加入点击滚动功能 #&#125;</span><br>&#123;% include <span class="hljs-string">'custom.swig'</span> %&#125;<br></code></pre></td></tr></table></figure><h3 id="4）重新生成博客"><a href="#4）重新生成博客" class="headerlink" title="4）重新生成博客"></a>4）重新生成博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本次主要实现的功能是，点击index页面中的标题或者其他组件，页面会自动向下滚动至文章版块。主要使用JavaScript插件&lt;code&gt;jquery&lt;/code&gt;实现&lt;/li&gt;
&lt;li&gt;使用本教程之前记得先将博客备份，以免出现不可逆损失&lt;/li&gt;
&lt;li&gt;Hexo版本：4.2.0&lt;/li&gt;
&lt;li&gt;NexT版本：7.7.1&lt;/li&gt;
&lt;li&gt;jquery版本：1.11.1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="个人博客搭建" scheme="https://tomandersen-cc.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Hexo" scheme="https://tomandersen-cc.github.io/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://tomandersen-cc.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>Kafka之获取指定Topic-Partition的Leader</title>
    <link href="https://tomandersen-cc.github.io/2020/03/17/Kafka%E4%B9%8B%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9ATopic-Partition%E7%9A%84Leader/"/>
    <id>https://tomandersen-cc.github.io/2020/03/17/Kafka%E4%B9%8B%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9ATopic-Partition%E7%9A%84Leader/</id>
    <published>2020-03-17T13:46:17.000Z</published>
    <updated>2020-03-17T13:48:26.717Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>kafka版本：2.11-2.1.1</li><li>基于Kafka Java API</li><li>主要是通过封装<code>Consumer.partitionsFor</code>方法实现此功能</li></ul><a id="more"></a><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br>     * &lt;p&gt;<br>     * 用于寻找指定Brokers-Topic-Partition对应的Leader.<br>     * 主要是封装了&#123;<span class="hljs-doctag">@link</span> KafkaConsumer#partitionsFor&#125;方法.<br>     *<br>     * <span class="hljs-doctag">@param</span> brokers   指定的Kafka集群,格式为&lt;"host","port"&gt;<br>     * <span class="hljs-doctag">@param</span> topic     指定的Topic<br>     * <span class="hljs-doctag">@param</span> partition 指定的Partition ID<br>     * <span class="hljs-doctag">@return</span> Node &#123;<span class="hljs-doctag">@link</span> Node&#125;<br>     * <span class="hljs-doctag">@date</span> 2020/3/17<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">findLeader</span><span class="hljs-params">(Map&lt;String, Integer&gt; brokers, String topic, <span class="hljs-keyword">int</span> partition)</span> </span>&#123;<br>        <span class="hljs-comment">// 1.通过接收到的配置信息创建KafkaConsumer实例</span><br>        Properties props = <span class="hljs-keyword">new</span> Properties();<br>        <span class="hljs-keyword">for</span> (String broker : brokers.keySet()) &#123;<br>            props.put(<span class="hljs-string">"bootstrap.servers"</span>,<br>                    broker + <span class="hljs-string">":"</span> + brokers.getOrDefault(broker, <span class="hljs-number">9092</span>));<br>        &#125;<br>        <span class="hljs-comment">// 指定Consumer所属的ConsumerGroup</span><br>        props.put(<span class="hljs-string">"group.id"</span>, <span class="hljs-string">"test"</span>);<br>        <span class="hljs-comment">// 设置手动提交Offset,由于只是获取部分数据所以不需要自动提交Offset</span><br>        props.put(<span class="hljs-string">"enable.auto.commit"</span>, <span class="hljs-string">"false"</span>);<br>        <span class="hljs-comment">// 设置键值对&lt;K,V&gt;反序列化器,使用String对象反序列化器</span><br>        props.put(<span class="hljs-string">"key.deserializer"</span>, <span class="hljs-string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);<br>        props.put(<span class="hljs-string">"value.deserializer"</span>, <span class="hljs-string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);<br><br>        <span class="hljs-comment">// 2.定义KafkaConsumer实例,采用try&#123;&#125;catch&#123;&#125;finally&#123;&#125;的方式获取资源</span><br>        KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 3.创建KafkaConsumer实例</span><br>            kafkaConsumer = <span class="hljs-keyword">new</span> KafkaConsumer&lt;&gt;(props);<br>            <span class="hljs-comment">// 4.通过KafkaConsumer实例获取指定Topic对应的Partition信息</span><br>            List&lt;PartitionInfo&gt; partitionInfos = kafkaConsumer.partitionsFor(topic);<br>            <span class="hljs-comment">// 5.遍历返回的指定Topic的所有Partition信息</span><br>            <span class="hljs-keyword">for</span> (PartitionInfo partitionInfo : partitionInfos) &#123;<br>                <span class="hljs-comment">// 若当前Partition是指定的Partition,则保存此Partition的Replication并将其Leader返回</span><br>                <span class="hljs-keyword">if</span> (partitionInfo.partition() == partition) &#123;<br>                    <span class="hljs-comment">/*// 保存指定Partition的所有副本<br>                    replications = partitionInfo.replicas();*/</span><br>                    <span class="hljs-comment">// 6.返回指定的TopicPartition对应的Leader</span><br>                    <span class="hljs-keyword">return</span> partitionInfo.leader();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (kafkaConsumer != <span class="hljs-keyword">null</span>) kafkaConsumer.close();<br>        &#125;<br>        <span class="hljs-comment">// 如果没有找到Leader则返回null</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;kafka版本：2.11-2.1.1&lt;/li&gt;
&lt;li&gt;基于Kafka Java API&lt;/li&gt;
&lt;li&gt;主要是通过封装&lt;code&gt;Consumer.partitionsFor&lt;/code&gt;方法实现此功能&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="https://tomandersen-cc.github.io/categories/Kafka/"/>
    
    
      <category term="Java" scheme="https://tomandersen-cc.github.io/tags/Java/"/>
    
      <category term="Kafka" scheme="https://tomandersen-cc.github.io/tags/Kafka/"/>
    
      <category term="Practice" scheme="https://tomandersen-cc.github.io/tags/Practice/"/>
    
  </entry>
  
  <entry>
    <title>Kafka之获取指定Topic-Partition的lastOffset</title>
    <link href="https://tomandersen-cc.github.io/2020/03/17/Kafka%E4%B9%8B%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9ATopic-Partition%E7%9A%84lastOffset/"/>
    <id>https://tomandersen-cc.github.io/2020/03/17/Kafka%E4%B9%8B%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9ATopic-Partition%E7%9A%84lastOffset/</id>
    <published>2020-03-17T13:46:17.000Z</published>
    <updated>2020-03-17T13:49:07.240Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>kafka版本：2.11-2.1.1</li><li>基于Kafka Java API</li><li>主要是通过封装<code>Conusmer.endOffsets</code>方法实现此功能</li></ul><a id="more"></a><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br>     * &lt;p&gt;根据指定的Topic-Partition获取对应的endOffset.<br>     * 主要是封装了KafkaConsumer的&#123;<span class="hljs-doctag">@link</span> KafkaConsumer#endOffsets&#125;方法.<br>     * &lt;p&gt;endOffsets Javadoc:<br>     * Get the end offsets for the given partitions. In the default &#123;<span class="hljs-doctag">@code</span> read_uncommitted&#125; isolation level, the end<br>     * offset is the high watermark (that is, the offset of the last successfully replicated message plus one). For<br>     * &#123;<span class="hljs-doctag">@code</span> read_committed&#125; consumers, the end offset is the last stable offset (LSO), which is the minimum of<br>     * the high watermark and the smallest offset of any open transaction. Finally, if the partition has never been<br>     * written to, the end offset is 0.<br>     *<br>     * <span class="hljs-doctag">@param</span> brokers   指定的Kafka集群<br>     * <span class="hljs-doctag">@param</span> topic     指定的Topic<br>     * <span class="hljs-doctag">@param</span> partition 指定的Partition ID<br>     * <span class="hljs-doctag">@return</span> TopicPartition对应最新消息的Offset<br>     * <span class="hljs-doctag">@date</span> 2020/3/17<br>     * <span class="hljs-doctag">@see</span> KafkaConsumer#endOffsets<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getLastOffset</span><span class="hljs-params">(Map&lt;String, Integer&gt; brokers, String topic, <span class="hljs-keyword">int</span> partition)</span> </span>&#123;<br>        <span class="hljs-comment">// 1.配置Consumer</span><br>        <span class="hljs-comment">// 通过接收到的配置信息创建KafkaConsumer实例</span><br>        Properties props = <span class="hljs-keyword">new</span> Properties();<br>        <span class="hljs-keyword">for</span> (String broker : brokers.keySet()) &#123;<br>            props.put(<span class="hljs-string">"bootstrap.servers"</span>,<br>                    broker + <span class="hljs-string">":"</span> + brokers.getOrDefault(broker, <span class="hljs-number">9092</span>));<br>        &#125;<br>        <span class="hljs-comment">// 指定Consumer所属的ConsumerGroup</span><br>        props.put(<span class="hljs-string">"group.id"</span>, <span class="hljs-string">"test"</span>);<br>        <span class="hljs-comment">// 设置手动提交Offset,由于只是获取部分数据所以不需要自动提交Offset</span><br>        props.put(<span class="hljs-string">"enable.auto.commit"</span>, <span class="hljs-string">"false"</span>);<br>        <span class="hljs-comment">// 设置键值对&lt;K,V&gt;反序列化器,直接使用String对象反序列化器</span><br>        props.put(<span class="hljs-string">"key.deserializer"</span>, <span class="hljs-string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);<br>        props.put(<span class="hljs-string">"value.deserializer"</span>, <span class="hljs-string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);<br><br>        <span class="hljs-comment">// 2.定义消费者KafkaConsumer对象</span><br>        KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 3.创建TopicPartition实例</span><br>        TopicPartition topicPartition = <span class="hljs-keyword">new</span> TopicPartition(topic, partition);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 4.创建kafkaTopic实例</span><br>            kafkaConsumer = <span class="hljs-keyword">new</span> KafkaConsumer&lt;&gt;(props);<br>            <span class="hljs-comment">// 5.通过Consumer.endOffsets(Collections&lt;TopicPartition&gt;)方法获取</span><br>            <span class="hljs-comment">// 指定TopicPartition对应的lastOffset</span><br>            Map offsets = kafkaConsumer.endOffsets(<br>                    Collections.singletonList(topicPartition));<br>            <span class="hljs-comment">// 6.返回对应Partition的Offset,如果不存在则直接返回0</span><br>            <span class="hljs-keyword">return</span> (Long) offsets.getOrDefault(topicPartition, <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (kafkaConsumer != <span class="hljs-keyword">null</span>) kafkaConsumer.close();<br>        &#125;<br>        <span class="hljs-comment">// 获取lastOffset失败则返回-1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;kafka版本：2.11-2.1.1&lt;/li&gt;
&lt;li&gt;基于Kafka Java API&lt;/li&gt;
&lt;li&gt;主要是通过封装&lt;code&gt;Conusmer.endOffsets&lt;/code&gt;方法实现此功能&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="https://tomandersen-cc.github.io/categories/Kafka/"/>
    
    
      <category term="Java" scheme="https://tomandersen-cc.github.io/tags/Java/"/>
    
      <category term="Kafka" scheme="https://tomandersen-cc.github.io/tags/Kafka/"/>
    
      <category term="Practice" scheme="https://tomandersen-cc.github.io/tags/Practice/"/>
    
  </entry>
  
  <entry>
    <title>Kafka之读取指定Topic-Partition-Offset之后的消息</title>
    <link href="https://tomandersen-cc.github.io/2020/03/17/Kafka%E4%B9%8B%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9ATopic-Partition-Offset%E4%B9%8B%E5%90%8E%E7%9A%84%E6%B6%88%E6%81%AF/"/>
    <id>https://tomandersen-cc.github.io/2020/03/17/Kafka%E4%B9%8B%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9ATopic-Partition-Offset%E4%B9%8B%E5%90%8E%E7%9A%84%E6%B6%88%E6%81%AF/</id>
    <published>2020-03-17T13:46:17.000Z</published>
    <updated>2020-03-17T13:48:00.062Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>kafka版本：2.11-2.1.1</li><li>基于Kafka Java API</li><li>主要是通过封装<code>Conusmer.assign</code>和<code>Consumer.seek</code>方法实现此功能。前者的作用是将指定Topic-Partition分配给对应的Consumer，后者的作用是将Consumer在指定的Topic-Partition中的Offset置于指定位置</li></ul><a id="more"></a><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br>     * &lt;p&gt;主要用于从指定的Topic-Partition-Offset读取指定数量的消息.<br>     * 主要是用于获取部分数据,而不是持续消费数据.主要是封装了&#123;<span class="hljs-doctag">@link</span> KafkaConsumer#assign&#125;<br>     * 和&#123;<span class="hljs-doctag">@link</span> KafkaConsumer#seek&#125;方法.<br>     *<br>     * <span class="hljs-doctag">@param</span> brokers     指定的Kafka集群<br>     * <span class="hljs-doctag">@param</span> topic       指定消费的Topic<br>     * <span class="hljs-doctag">@param</span> partition   指定消费的Partition ID<br>     * <span class="hljs-doctag">@param</span> beginOffset 指定开始消费的Offset<br>     * <span class="hljs-doctag">@param</span> timeInMills 指定消费的时长<br>     * <span class="hljs-doctag">@param</span> maxReads    指定消费的最大消息数<br>     * <span class="hljs-doctag">@date</span> 2020/3/17<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;ConsumerRecord&gt; <span class="hljs-title">getRecordsFrom</span><span class="hljs-params">(Map&lt;String, Integer&gt; brokers, String topic, <span class="hljs-keyword">int</span> partition, <span class="hljs-keyword">long</span> beginOffset, <span class="hljs-keyword">long</span> timeInMills, <span class="hljs-keyword">long</span> maxReads)</span> </span>&#123;<br>        <span class="hljs-comment">// 1.通过接收到的配置信息创建KafkaConsumer实例</span><br>        Properties props = <span class="hljs-keyword">new</span> Properties();<br>        <span class="hljs-keyword">for</span> (String broker : brokers.keySet()) &#123;<br>            props.put(<span class="hljs-string">"bootstrap.servers"</span>,<br>                    broker + <span class="hljs-string">":"</span> + brokers.getOrDefault(broker, <span class="hljs-number">9092</span>));<br>        &#125;<br>        <span class="hljs-comment">// 设置手动提交Offset,由于只是获取部分数据所以不需要自动提交Offset</span><br>        props.put(<span class="hljs-string">"enable.auto.commit"</span>, <span class="hljs-string">"false"</span>);<br>        <span class="hljs-comment">// 设置键值对&lt;K,V&gt;反序列化器,因为都是String类型,所以使用String对象反序列化器</span><br>        props.put(<span class="hljs-string">"key.deserializer"</span>, <span class="hljs-string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);<br>        props.put(<span class="hljs-string">"value.deserializer"</span>, <span class="hljs-string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);<br><br>        <span class="hljs-comment">// 2.定义KafkaConsumer对象,以及创建用于返回的ConsumerRecord集合</span><br>        KafkaConsumer&lt;Object, Object&gt; kafkaConsumer = <span class="hljs-keyword">null</span>;<br>        List&lt;ConsumerRecord&gt; recordList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 3.创建KafkaConsumer实例</span><br>            kafkaConsumer = <span class="hljs-keyword">new</span> KafkaConsumer&lt;&gt;(props);<br>            <span class="hljs-comment">// 4.创建TopicPartition实例</span><br>            TopicPartition topicPartition = <span class="hljs-keyword">new</span> TopicPartition(topic, partition);<br>            <span class="hljs-comment">// 5.给Consumer指定消费的Topic和Partition(十分重要)</span><br>            <span class="hljs-comment">// 如果无对应topic或者partition,则会抛出异常IllegalArgumentException</span><br>            <span class="hljs-comment">// 如果此consumer之前已经有过订阅行为且未解除之前所有的订阅,则会抛出异常IllegalStateException</span><br>            kafkaConsumer.assign(Collections.singletonList(topicPartition));<br>            <span class="hljs-comment">// 6.覆盖原始的Consumer-Topic-Partition对应的Offset,将其设置为指定Offset值</span><br>            kafkaConsumer.seek(topicPartition, beginOffset);<br>            <span class="hljs-comment">// 7.获取消息</span><br>            ConsumerRecords&lt;Object, Object&gt; consumerRecords =<br>                    kafkaConsumer.poll(Duration.ofMillis(timeInMills));<br>            <span class="hljs-comment">// 8.处理消息</span><br>            <span class="hljs-comment">// 将Consumer获取到的消息保存在集合中准备返回</span><br>            <span class="hljs-keyword">for</span> (ConsumerRecord record : consumerRecords) &#123;<br>                <span class="hljs-comment">// 如果已经读完最多消息限制则直接跳出循环</span><br>                <span class="hljs-keyword">if</span> (recordList.size() == maxReads) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 如果还需要读取则继续读取</span><br>                recordList.add(record);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 9.释放资源</span><br>            <span class="hljs-keyword">if</span> (kafkaConsumer != <span class="hljs-keyword">null</span>) kafkaConsumer.close();<br>        &#125;<br>        <span class="hljs-keyword">return</span> recordList;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;kafka版本：2.11-2.1.1&lt;/li&gt;
&lt;li&gt;基于Kafka Java API&lt;/li&gt;
&lt;li&gt;主要是通过封装&lt;code&gt;Conusmer.assign&lt;/code&gt;和&lt;code&gt;Consumer.seek&lt;/code&gt;方法实现此功能。前者的作用是将指定Topic-Partition分配给对应的Consumer，后者的作用是将Consumer在指定的Topic-Partition中的Offset置于指定位置&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="https://tomandersen-cc.github.io/categories/Kafka/"/>
    
    
      <category term="Java" scheme="https://tomandersen-cc.github.io/tags/Java/"/>
    
      <category term="Kafka" scheme="https://tomandersen-cc.github.io/tags/Kafka/"/>
    
      <category term="Practice" scheme="https://tomandersen-cc.github.io/tags/Practice/"/>
    
  </entry>
  
  <entry>
    <title>ssh连接服务器时出现Permission denied (publickey,gssapi-keyex,gssapi-with-mic)</title>
    <link href="https://tomandersen-cc.github.io/2020/03/15/ssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E5%87%BA%E7%8E%B0Permission%20denied%20(publickey,gssapi-keyex,gssapi-with-mic)/"/>
    <id>https://tomandersen-cc.github.io/2020/03/15/ssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E5%87%BA%E7%8E%B0Permission%20denied%20(publickey,gssapi-keyex,gssapi-with-mic)/</id>
    <published>2020-03-15T00:04:49.000Z</published>
    <updated>2020-03-20T00:33:53.438Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SSH工具连接服务器的身份验证方式有两种，一种是基于口令的身份验证，一种是基于密钥的身份认证。当你直接使用SSH工具连接服务器时，SSH首先会在<code>~/.ssh/</code>路径下按照默认的密钥（私钥）文件名（如id_rsa）查找对应的密钥并尝试使用本地的私钥去配对服务器端的公钥，如果配对成功则不需要进行密码验证（这也是通常实现SSH免密登录的原理），如果配对失败则尝试使用密码验证的方式进行身份验证。但是如果ssh配置文件中关闭了密码验证，那么当密钥无法配对成功时，就会报如题的错误。同样的如果在没有开启密码验证的时候，尝试使用<code>ssh-copy-id</code>，也会报此错误。</p><a id="more"></a><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1）使用对应私钥连接服务端"><a href="#1）使用对应私钥连接服务端" class="headerlink" title="1）使用对应私钥连接服务端"></a>1）使用对应私钥连接服务端</h3><p><strong>命令格式如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh &lt;remote_username&gt;@&lt;remote_ip&gt; -i &lt;your_local_private_key&gt;<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh admin@114.67.40.28 -i /home/tom/id_rsa<br></code></pre></td></tr></table></figure><p><strong>注意：如果是在Windows平台下使用Git Bash，则默认密钥（私钥）一般存放在<code>C:\Users\&lt;your_account&gt;\.ssh</code>目录下。如果没有对应私钥是没有办法连接到远端的。</strong></p><h3 id="2）修改SSH配置文件"><a href="#2）修改SSH配置文件" class="headerlink" title="2）修改SSH配置文件"></a>2）修改SSH配置文件</h3><p><strong>修改/etc/ssh/sshd_config：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p><strong>将PasswordAuthentication设置成为yes（一般在文件的末尾几行）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#X11Forwarding no</span><br><span class="hljs-comment">#AllowTcpForwarding no</span><br><span class="hljs-comment">#PermitTTY no</span><br><span class="hljs-comment">#ForceCommand cvs server</span><br>UseDNS no<br>AddressFamily inet<br>PermitRootLogin yes<br>SyslogFacility AUTHPRIV<br><span class="hljs-comment">#PasswordAuthentication no</span><br>PasswordAuthentication yes<br></code></pre></td></tr></table></figure><p><strong>注意：不是修改<code>/etc/ssh/ssh_config</code>文件</strong></p><h3 id="3）使用密码登录"><a href="#3）使用密码登录" class="headerlink" title="3）使用密码登录"></a>3）使用密码登录</h3><p><strong>修改配置之后就可以正常使用密码的方式进行身份验证登录服务器了</strong></p><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;SSH工具连接服务器的身份验证方式有两种，一种是基于口令的身份验证，一种是基于密钥的身份认证。当你直接使用SSH工具连接服务器时，SSH首先会在&lt;code&gt;~/.ssh/&lt;/code&gt;路径下按照默认的密钥（私钥）文件名（如id_rsa）查找对应的密钥并尝试使用本地的私钥去配对服务器端的公钥，如果配对成功则不需要进行密码验证（这也是通常实现SSH免密登录的原理），如果配对失败则尝试使用密码验证的方式进行身份验证。但是如果ssh配置文件中关闭了密码验证，那么当密钥无法配对成功时，就会报如题的错误。同样的如果在没有开启密码验证的时候，尝试使用&lt;code&gt;ssh-copy-id&lt;/code&gt;，也会报此错误。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Shell" scheme="https://tomandersen-cc.github.io/categories/Shell/"/>
    
    
      <category term="Linux" scheme="https://tomandersen-cc.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="https://tomandersen-cc.github.io/tags/Shell/"/>
    
      <category term="ssh" scheme="https://tomandersen-cc.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Shell之使用ssh工具在远端执行多条命令</title>
    <link href="https://tomandersen-cc.github.io/2020/03/15/Shell%E4%B9%8B%E4%BD%BF%E7%94%A8ssh%E5%B7%A5%E5%85%B7%E5%9C%A8%E8%BF%9C%E7%AB%AF%E6%89%A7%E8%A1%8C%E5%A4%9A%E6%9D%A1%E5%91%BD%E4%BB%A4/"/>
    <id>https://tomandersen-cc.github.io/2020/03/15/Shell%E4%B9%8B%E4%BD%BF%E7%94%A8ssh%E5%B7%A5%E5%85%B7%E5%9C%A8%E8%BF%9C%E7%AB%AF%E6%89%A7%E8%A1%8C%E5%A4%9A%E6%9D%A1%E5%91%BD%E4%BB%A4/</id>
    <published>2020-03-15T00:03:15.000Z</published>
    <updated>2020-03-21T08:57:00.902Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p><strong>①多行命令使用双引号或者首尾定界符来囊括，当使用双引号囊括时，若其中同时也使用了双引号就需要使用转义字符对远程执行命令中的引号进行转义。所以如果远程命令本身包含双引号，建议还是使用首尾定界符，首尾定界符是一个自定义的字符串，可以自定义内容，并且命令结尾处的首尾定界符需要放置于当前行行首</strong></p></li><li><p><strong>②如果远程执行命令中的美元符号<code>$</code>读取的是远程终端的变量，而非当前终端的变量就需要增加转义字符来将此美元符号转义，即定义为读取远程终端中设置的变量</strong></p></li></ul><a id="more"></a><hr><h2 id="脚本示例"><a href="#脚本示例" class="headerlink" title="脚本示例"></a>脚本示例</h2><h3 id="示例1：使用双引号"><a href="#示例1：使用双引号" class="headerlink" title="示例1：使用双引号"></a>示例1：使用双引号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># 此脚本用于测试ssh工具远程执行多条命令方式</span><br><span class="hljs-comment"># 使用的前提是已经设置密钥对并以默认私钥文件名存放在默认路径~/.ssh/下(即ssh免密登录)</span><br><span class="hljs-comment"># 或者使用-i参数手动指定私钥位置</span><br><br>host=192.168.126.101<br><br>ssh tomandersen@<span class="hljs-variable">$host</span> <span class="hljs-string">"<br>source /etc/profile<br>echo \$JAVA_HOME<br>echo 'this is a test!'<br>"</span><br></code></pre></td></tr></table></figure><p><strong>注意：每行结尾不加分号<code>;</code>，若远程执行的多行命令中存在使用<code>双引号&quot;&quot;</code>或者<code>美元符号$</code>的情况，需要使用<code>转义字符\</code>进行转义，前者是因为双引号在本示例中是作为首位定界符只能出现在命令头尾，后者是因为不给美元符号附上转义字符时是默认读取本地变量。同理也可以使用单引号</strong></p><hr><h3 id="示例2：使用首尾定界符"><a href="#示例2：使用首尾定界符" class="headerlink" title="示例2：使用首尾定界符"></a>示例2：使用首尾定界符</h3><p><strong>首尾定界符是用于圈定命令的字符串，字符串内容可以自己定义，如常用的EOF，甚至命名为TEST都行。配合使用输入从定向&lt;&lt;，能够将其圈定的内容作为命令参数输入</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># 此脚本用于测试ssh工具远程执行多条命令方式</span><br><span class="hljs-comment"># 使用的前提是已经设置密钥对并以默认私钥文件名存放在默认路径~/.ssh/下(即ssh免密登录)</span><br><span class="hljs-comment"># 或者使用-i参数手动指定私钥位置</span><br><br>host=192.168.126.101<br><br>ssh tomandersen@<span class="hljs-variable">$host</span> &lt;&lt; EOF<br><span class="hljs-built_in">source</span> /etc/profile<br><span class="hljs-built_in">echo</span> \<span class="hljs-variable">$JAVA_HOME</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">'this is a test!'</span><br>EOF<br></code></pre></td></tr></table></figure><p><strong>注意：首尾定界符的结尾符号需要写在行首，否则会报错</strong></p><p><strong>若需要清除<code>Pseudo-terminal will not be allocated because stdin is not a terminal</code>输出文本，可以将标准错误信息输出重定向至“黑洞”即可</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">host=192.168.126.101<br><br>ssh tomandersen@<span class="hljs-variable">$host</span> 2&gt;/dev/null &lt;&lt; EOF<br><span class="hljs-built_in">source</span> /etc/profile<br><span class="hljs-built_in">echo</span> \<span class="hljs-variable">$JAVA_HOME</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">'this is a test!'</span><br>EOF<br></code></pre></td></tr></table></figure><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;①多行命令使用双引号或者首尾定界符来囊括，当使用双引号囊括时，若其中同时也使用了双引号就需要使用转义字符对远程执行命令中的引号进行转义。所以如果远程命令本身包含双引号，建议还是使用首尾定界符，首尾定界符是一个自定义的字符串，可以自定义内容，并且命令结尾处的首尾定界符需要放置于当前行行首&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;②如果远程执行命令中的美元符号&lt;code&gt;$&lt;/code&gt;读取的是远程终端的变量，而非当前终端的变量就需要增加转义字符来将此美元符号转义，即定义为读取远程终端中设置的变量&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Shell" scheme="https://tomandersen-cc.github.io/categories/Shell/"/>
    
    
      <category term="Linux" scheme="https://tomandersen-cc.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="https://tomandersen-cc.github.io/tags/Shell/"/>
    
      <category term="ssh" scheme="https://tomandersen-cc.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Kafka之入门级安装部署</title>
    <link href="https://tomandersen-cc.github.io/2020/03/15/Kafka%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    <id>https://tomandersen-cc.github.io/2020/03/15/Kafka%E4%B9%8B%E5%85%A5%E9%97%A8%E7%BA%A7%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</id>
    <published>2020-03-15T00:01:13.000Z</published>
    <updated>2020-03-17T13:55:42.028Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="1-下载Kafka安装包"><a href="#1-下载Kafka安装包" class="headerlink" title="1. 下载Kafka安装包"></a>1. 下载Kafka安装包</h2><p><a href="http://archive.apache.org/dist/" target="_blank" rel="noopener">Apache所有项目历史版本镜像地址</a></p><p><a href="http://archive.apache.org/dist/kafka/" target="_blank" rel="noopener">Apache Kafka下载地址</a></p><a id="more"></a><hr><h2 id="2-解压到指定路径下"><a href="#2-解压到指定路径下" class="headerlink" title="2. 解压到指定路径下"></a>2. 解压到指定路径下</h2><p><strong>本次安装的Kafka为2.1.1版本，注意：压缩包前面的版本号为Scala版本号，而后面的才是Kafka版本号</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xzvf kafka_2.11-2.1.1.tgz -C /opt/module/<br></code></pre></td></tr></table></figure><hr><h2 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3. 配置环境变量"></a>3. 配置环境变量</h2><p><strong>通过修改<code>/etc/profile</code>文件设置KAFKA_HOME环境变量，并将bin目录增加到PATH环境变量中</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/profile<br></code></pre></td></tr></table></figure><p><strong>添加以下内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Set $KAFKA_HOME</span><br><span class="hljs-built_in">export</span> KAFKA_HOME=/opt/module/kafka_2.11-2.1.1<br><span class="hljs-comment"># Add $KAFKA_HOME/bin to PATH</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$KAFKA_HOME</span>/bin<br></code></pre></td></tr></table></figure><p><strong>重新加载profile文件，验证环境变量</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$KAFKA_HOME</span><br></code></pre></td></tr></table></figure><hr><h2 id="4-修改配置文件config-server-properties"><a href="#4-修改配置文件config-server-properties" class="headerlink" title="4. 修改配置文件config/server.properties"></a>4. 修改配置文件<code>config/server.properties</code></h2><h3 id="1）设置Broker-ID"><a href="#1）设置Broker-ID" class="headerlink" title="1）设置Broker ID"></a>1）设置Broker ID</h3><p><strong>Kafka集群中每个主机即Broker的ID必须不同</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># The id of the broker. This must be set to a unique integer for each broker.</span><br>broker.id=0<br></code></pre></td></tr></table></figure><h3 id="2）设置Kafka日志以及数据存放路径"><a href="#2）设置Kafka日志以及数据存放路径" class="headerlink" title="2）设置Kafka日志以及数据存放路径"></a>2）设置Kafka日志以及数据存放路径</h3><p><strong>此路径设置的日志和数据的共同存储路径，即各种Partition的数据也存储在此路径下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">log.dirs=/opt/module/kafka_2.11-2.1.1/logs<br></code></pre></td></tr></table></figure><h3 id="3）开启管理工具的删除Topic功能"><a href="#3）开启管理工具的删除Topic功能" class="headerlink" title="3）开启管理工具的删除Topic功能"></a>3）开启管理工具的删除Topic功能</h3><p><strong>如果不开启开启此功能，那么使用命令行删除Topic时只会是标记删除，实际上并未删除，当再次创建同名Topic时就会报错无法创建</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">delete.topic.enable=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="4）配置Zookeeper集群"><a href="#4）配置Zookeeper集群" class="headerlink" title="4）配置Zookeeper集群"></a>4）配置Zookeeper集群</h3><p><strong>Zookeeper服务器集群的客户端端口要与Zookeeper中配置的端口一致</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">zookeeper.connect=zkServer1:2181,zkServer2.2181,zkServer3.2181<br></code></pre></td></tr></table></figure><h3 id="5）具体配置"><a href="#5）具体配置" class="headerlink" title="5）具体配置"></a>5）具体配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#broker的全局唯一编号，不能重复</span><br>broker.id=1<br><span class="hljs-comment">#删除topic功能使能</span><br>delete.topic.enable=<span class="hljs-literal">true</span><br><span class="hljs-comment">#处理网络请求的线程数量</span><br>num.network.threads=3<br><span class="hljs-comment">#用来处理磁盘IO的现成数量</span><br>num.io.threads=8<br><span class="hljs-comment">#发送套接字的缓冲区大小</span><br>socket.send.buffer.bytes=102400<br><span class="hljs-comment">#接收套接字的缓冲区大小</span><br>socket.receive.buffer.bytes=102400<br><span class="hljs-comment">#请求套接字的缓冲区大小</span><br>socket.request.max.bytes=104857600<br><span class="hljs-comment">#kafka运行日志存放的路径</span><br>log.dirs=/opt/module/kafka_2.11-2.1.1/logs<br><span class="hljs-comment">#topic在当前broker上的分区个数</span><br>num.partitions=1<br><span class="hljs-comment">#用来恢复和清理data下数据的线程数量</span><br>num.recovery.threads.per.data.dir=1<br><span class="hljs-comment">#segment文件保留的最长时间，超时将被删除</span><br>log.retention.hours=168<br><span class="hljs-comment">#log segment滚动条件:文件大小</span><br>log.segment.bytes=1073741824<br><span class="hljs-comment">#周期性检查log segment文件是否可以删除</span><br>log.retention.check.interval.ms=300000<br><span class="hljs-comment">#配置连接Zookeeper集群地址</span><br>zookeeper.connect=hadoop102:2181,hadoop103:2181,hadoop104:2181<br><span class="hljs-comment">#zookeeper连接认定超时时间</span><br>zookeeper.connection.timeout.ms=6000<br><span class="hljs-comment">#设置rebalance的延迟时间</span><br>group.initial.rebalance.delay.ms=0<br></code></pre></td></tr></table></figure><h3 id="6）测试"><a href="#6）测试" class="headerlink" title="6）测试"></a>6）测试</h3><p><strong>启动当前主机Kafka</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kafka-server-start.sh config/server.properties<br></code></pre></td></tr></table></figure><p><strong>关闭当前主机Kafka</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kafka-server-stop.sh<br></code></pre></td></tr></table></figure><h3 id="7）将Kafka分发给其他主机并修改对应的Broker-ID即可"><a href="#7）将Kafka分发给其他主机并修改对应的Broker-ID即可" class="headerlink" title="7）将Kafka分发给其他主机并修改对应的Broker ID即可"></a>7）将Kafka分发给其他主机并修改对应的Broker ID即可</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp -r /opt/module/kafka_2.11-2.1.1 hadoop102:/opt/module/<br>scp -r /opt/module/kafka_2.11-2.1.1 hadoop103:/opt/module/<br></code></pre></td></tr></table></figure><h3 id="8）编写脚本控制Kafka集群"><a href="#8）编写脚本控制Kafka集群" class="headerlink" title="8）编写脚本控制Kafka集群"></a>8）编写脚本控制Kafka集群</h3><p><strong>编写Kafka群起脚本，通过脚本控制Kafka集群。此处提供脚本模板，仅供参考，具体使用之前记得更改Kafka安装路径，以及实现主机间ssh免密登录或者更改ssh命令指定每次连接时使用的私钥</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 此脚本用于启动/停止Kafka集群</span><br><span class="hljs-comment"># 输入的参数只能为start/stop</span><br><br><span class="hljs-comment"># 判断参数个数</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-variable">$#</span> &gt; 1)); <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"Wrongs parameters!"</span><br>    <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 获取当前时间(相对时间)</span><br>start_time=$(date +%s)<br><span class="hljs-comment"># 获取操作方式</span><br>operation=<span class="hljs-variable">$1</span><br><span class="hljs-comment"># 设置Kafka集群</span><br>cluster=<span class="hljs-variable">$&#123;KAFKA_CLUSTER:-"hadoop101 hadoop102 hadoop103"&#125;</span><br><br><span class="hljs-comment"># 对kafka集群进行对应的操作</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">"<span class="hljs-variable">$operation</span>"</span> <span class="hljs-keyword">in</span><br>start)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"----------Starting kafka cluster----------"</span><br>    <span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> <span class="hljs-variable">$cluster</span>; <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"----------Starting kafka in [<span class="hljs-variable">$host</span>]----------"</span><br>        ssh <span class="hljs-variable">$host</span> <span class="hljs-string">"source /etc/profile;<br>        KAFKA_HOME=\$&#123;KAFKA_HOME:-'/opt/module/kafka_2.11-2.1.1'&#125;;<br>        cd \$KAFKA_HOME;<br>        nohup ./bin/kafka-server-start.sh config/server.properties &gt; /dev/null 2&gt;&amp;1 &amp;<br>        "</span><br>    <span class="hljs-keyword">done</span><br>    ;;<br>stop)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"----------Stopping kafka cluster----------"</span><br>    <span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> <span class="hljs-variable">$cluster</span>; <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"----------Starting kafka in [<span class="hljs-variable">$host</span>]----------"</span><br>        ssh <span class="hljs-variable">$host</span> <span class="hljs-string">"source /etc/profile;<br>        KAFKA_HOME=\$&#123;KAFKA_HOME:-'/opt/module/kafka_2.11-2.1.1'&#125;;<br>        cd \$KAFKA_HOME;<br>        ./bin/kafka-server-stop.sh<br>        "</span><br>    <span class="hljs-keyword">done</span><br>    ;;<br>*)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"Worong Parameter!"</span><br>    <span class="hljs-built_in">exit</span> 1<br>    ;;<br><span class="hljs-keyword">esac</span><br><br><span class="hljs-comment"># 获取结束时间</span><br>end_time=$(date +%s)<br>execution_time=$((<span class="hljs-variable">$&#123;end_time&#125;</span> - <span class="hljs-variable">$&#123;start_time&#125;</span>))<br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\n----------<span class="hljs-variable">$operation</span> kafka in [<span class="hljs-variable">$cluster</span>] takes <span class="hljs-variable">$&#123;execution_time&#125;</span> seconds----------\n"</span><br></code></pre></td></tr></table></figure><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;1-下载Kafka安装包&quot;&gt;&lt;a href=&quot;#1-下载Kafka安装包&quot; class=&quot;headerlink&quot; title=&quot;1. 下载Kafka安装包&quot;&gt;&lt;/a&gt;1. 下载Kafka安装包&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://archive.apache.org/dist/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apache所有项目历史版本镜像地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://archive.apache.org/dist/kafka/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apache Kafka下载地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="https://tomandersen-cc.github.io/categories/Kafka/"/>
    
    
      <category term="Linux" scheme="https://tomandersen-cc.github.io/tags/Linux/"/>
    
      <category term="Kafka" scheme="https://tomandersen-cc.github.io/tags/Kafka/"/>
    
      <category term="Shell" scheme="https://tomandersen-cc.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Kafka之命令行的基本操作</title>
    <link href="https://tomandersen-cc.github.io/2020/03/15/Kafka%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://tomandersen-cc.github.io/2020/03/15/Kafka%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2020-03-15T00:00:04.000Z</published>
    <updated>2020-03-17T13:51:24.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>kafka版本：2.11-2.1.1</li></ul><a id="more"></a><hr><h2 id="1-启动-关闭Kafka"><a href="#1-启动-关闭Kafka" class="headerlink" title="1. 启动/关闭Kafka"></a>1. 启动/关闭Kafka</h2><p><strong>注意：在启动Kafka进程之前记得先启动Zookeeper集群</strong></p><p><strong>启动当前主机Kafka进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kafka-server-start.sh config/server.properties<br></code></pre></td></tr></table></figure><p><strong>可以使用<code>-daemon</code>参数，表示以守护线程的方式启动，日志不打印到控制台</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kafka-server-start.sh -daemon config/server.properties<br></code></pre></td></tr></table></figure><p><strong>关闭当前主机Kafka进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kafka-server-stop.sh<br></code></pre></td></tr></table></figure><h2 id="2-查看所有Topic信息"><a href="#2-查看所有Topic信息" class="headerlink" title="2. 查看所有Topic信息"></a>2. 查看所有Topic信息</h2><p><strong>需要指定Zookeeper集群和其提供的客户端端口号。如果想尝试使用多个Zookeeper服务器，各个服务器之间使用逗号隔开</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kafka-topics.sh --zookeeper zkServer1:2181,zkServer2:2181 --list<br></code></pre></td></tr></table></figure><h2 id="3-创建Topic"><a href="#3-创建Topic" class="headerlink" title="3. 创建Topic"></a>3. 创建Topic</h2><p><strong>向Zookeeper服务器集群注册Topic</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kafka-topics.sh --zookeeper zkServer1:2181 --create --replication-factor 3 --partitions 1 --topic first<br></code></pre></td></tr></table></figure><p><strong>注意：自Kafka 2.2.x及之后都是向Kafka集群注册Topic，而不是直接向Zookeeper注册Tpoic，所以命令行有所不同，将Zookeeper集群改成指定Kafka集群及其客户端端口</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 3 --partitions 1 --topic first<br></code></pre></td></tr></table></figure><h2 id="4-删除Topic"><a href="#4-删除Topic" class="headerlink" title="4. 删除Topic"></a>4. 删除Topic</h2><p><strong>需要server.properties中设置<code>delete.topic.enable=true</code>，否则只是标记删除而实际未删除，会导致再次创建同名Topic时失败</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kafka-topics.sh --zookeeper zkServer1:2181 --delete --topic first<br></code></pre></td></tr></table></figure><h2 id="5-生产消息"><a href="#5-生产消息" class="headerlink" title="5. 生产消息"></a>5. 生产消息</h2><p><strong>启动生产者进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic first<br></code></pre></td></tr></table></figure><h2 id="6-消费消息"><a href="#6-消费消息" class="headerlink" title="6. 消费消息"></a>6. 消费消息</h2><p><strong>启动消费者进程，实时消费Topic中的最新消息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic first<br></code></pre></td></tr></table></figure><p><strong>加上<code>from-beginning</code>则是将Topic中已保存的历史消息全部取出</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --from-beginning --topic first<br></code></pre></td></tr></table></figure><p><strong>注意1：如果使用了多个Partition，取出的消息只能保证单个Partition中的消息有序，多个Partition之间消息是不保证有序的</strong></p><p><strong>注意2：在Kafka 0.8.1及之前，Consumer消费分区消息的offset偏移量也通过Zookeeper来保存，在此版本之后就不建议或者禁止使用zk来保存offset。在Kafka 0.8.2及之后，Kafka通过建立一个Internal Topic即内部Topic来保存Consumer Offset信息（topic名为_consumer_offset），同样存储在log.dirs路径下。因此Kafka 0.8.2及之后是通过指定Kafka集群来消费消息，而Kafka 0.8.1及之前是通过指定Zookeeper集群来消费消息</strong></p><h2 id="7-查看指定Topic具体信息"><a href="#7-查看指定Topic具体信息" class="headerlink" title="7. 查看指定Topic具体信息"></a>7. 查看指定Topic具体信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/kafka-topics.sh --zookeeper zkServer1:2181 --describe --topic first<br></code></pre></td></tr></table></figure><p><strong>其中<code>ISR</code>表示已经和Partition Leader实现同步的Partition副本（in-sync replication）</strong></p><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;kafka版本：2.11-2.1.1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="https://tomandersen-cc.github.io/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="https://tomandersen-cc.github.io/tags/Kafka/"/>
    
      <category term="Shell" scheme="https://tomandersen-cc.github.io/tags/Shell/"/>
    
      <category term="Practice" scheme="https://tomandersen-cc.github.io/tags/Practice/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之NexT主题设置背景图片</title>
    <link href="https://tomandersen-cc.github.io/2020/03/15/Hexo%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/"/>
    <id>https://tomandersen-cc.github.io/2020/03/15/Hexo%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/</id>
    <published>2020-03-14T23:58:04.000Z</published>
    <updated>2020-03-17T13:52:09.058Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>Hexo版本</strong>：4.2.0</li><li><strong>NexT版本</strong>：7.7.1</li><li><strong>GitHub</strong>：<a href="https://github.com/theme-next/theme-next-pace" target="_blank" rel="noopener">theme-next-pace</a></li></ul><a id="more"></a><hr><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><h3 id="1）修改NexT配置文件"><a href="#1）修改NexT配置文件" class="headerlink" title="1）修改NexT配置文件"></a>1）修改NexT配置文件</h3><p>在NexT的配置文件中的<code>custom_file_path</code>参数下设置CSS样式文件<code>style.styl</code>的存储路径，我们可以在此文件中自定义使用自己的各种样式，此路径必须在Hexo根目录source文件夹下，建议设置成默认路径<code>source/_data/style.styl</code>，然后在对应路径下创建对应的<code>style.styl</code>文件。</p><h3 id="2）配置style-styl文件"><a href="#2）配置style-styl文件" class="headerlink" title="2）配置style.styl文件"></a>2）配置style.styl文件</h3><p><strong>此脚本内容遵循CSS语法，以下是配置示例：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs css">// Custom styles.<br>// 整体背景设置<br>body &#123;<br> background:url(/images/adrian-Xft-JdC-Jbc-unsplash.jpg);// 设定背景图片,images同处于source文件夹下<br> background-repeat: no-repeat;// 设定背景图片非重复填充<br>    background-attachment:fixed;// 设置背景图片不随页面滚动<br>    background-position:50% 50%;// 设置背景图片位置<br>background-size: cover// 设置保持图像的纵横比并将图像缩放成将完全覆盖背景定位区域的最小大小<br>&#125;<br><br>// 页面头样式属性<br>.header-inner &#123;<br>  // 也可以同时定义背景色<br>  // background: #ddd <br>  // 透明度<br>  // opacity: 0.8;<br>&#125;<br>// sidebar侧边工具栏样式属性<br>.sidebar&#123;<br>    // 动画过渡时间<br>transition-duration: 0.4s;<br>    // 透明度<br>opacity: 0.8<br>&#125;<br>// 标题样式<br>.posts-expand .post-title-link &#123;<br>// 设置字体颜色<br>color: #222;<br>&#125;<br><br>// 文章版块样式<br>.post-block &#123;<br>    //background: var(--content-bg-color);<br>background: #fff<br>    border-radius: initial;<br>    box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);<br>    padding: 40px;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3）重新生成Hexo博客"><a href="#3）重新生成Hexo博客" class="headerlink" title="3）重新生成Hexo博客"></a>3）重新生成Hexo博客</h3><p><strong>重新生成Hexo博客，并验证配置结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><h3 id="4）More"><a href="#4）More" class="headerlink" title="4）More"></a>4）More</h3><p><strong>类似的，我们也可以通过浏览器的F12进入开发者模式并使用鼠标点击来获取CSS样式名，并在此文件中设置对应的样式属性来实现各种自定义修改的CSS样式</strong></p><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hexo版本&lt;/strong&gt;：4.2.0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NexT版本&lt;/strong&gt;：7.7.1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GitHub&lt;/strong&gt;：&lt;a href=&quot;https://github.com/theme-next/theme-next-pace&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;theme-next-pace&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="个人博客搭建" scheme="https://tomandersen-cc.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Blog" scheme="https://tomandersen-cc.github.io/tags/Blog/"/>
    
      <category term="Hexo" scheme="https://tomandersen-cc.github.io/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://tomandersen-cc.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之NexT主题中设置加载进度条</title>
    <link href="https://tomandersen-cc.github.io/2020/03/06/Hexo%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    <id>https://tomandersen-cc.github.io/2020/03/06/Hexo%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%9D%A1/</id>
    <published>2020-03-06T04:14:35.000Z</published>
    <updated>2020-03-12T04:19:16.746Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>Hexo版本</strong>：4.2.0</li><li><strong>NexT版本</strong>：7.7.1</li><li><strong>GitHub</strong>：<a href="https://github.com/theme-next/theme-next-pace" target="_blank" rel="noopener">theme-next-pace</a></li><li><strong>各种进度条样式参考</strong>：<a href="https://blog.pangao.vip/Hexo博客NexT主题美化之顶部加载进度条/" target="_blank" rel="noopener">Hexo博客NexT主题美化之顶部加载进度条</a></li></ul><hr><a id="more"></a><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><h3 id="1）进入NexT主题文件夹"><a href="#1）进入NexT主题文件夹" class="headerlink" title="1）进入NexT主题文件夹"></a>1）进入NexT主题文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> themes/next/<br>$ ls<br>_config.yml  docs/        languages/  LICENSE.md    README.md  <span class="hljs-built_in">source</span>/<br>crowdin.yml  gulpfile.js  layout/     package.json  scripts/<br></code></pre></td></tr></table></figure><h3 id="2）克隆Github仓库（如果使用CDN可跳过此步骤）"><a href="#2）克隆Github仓库（如果使用CDN可跳过此步骤）" class="headerlink" title="2）克隆Github仓库（如果使用CDN可跳过此步骤）"></a>2）克隆Github仓库（如果使用CDN可跳过此步骤）</h3><p><strong>将仓库克隆至<code>themes/next/source/lib</code>路径下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/theme-next/theme-next-pace <span class="hljs-built_in">source</span>/lib/pace<br></code></pre></td></tr></table></figure><h3 id="3）配置NexT中的-config-xml"><a href="#3）配置NexT中的-config-xml" class="headerlink" title="3）配置NexT中的_config.xml"></a>3）配置NexT中的<code>_config.xml</code></h3><p><strong>开启pace选项</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Progress bar in the top during page loading.</span><br><span class="hljs-comment"># 设置页面加载时顶部进度条</span><br><span class="hljs-comment"># Dependencies: https://github.com/theme-next/theme-next-pace</span><br><span class="hljs-comment"># For more information: https://github.com/HubSpot/pace</span><br>pace:<br>  <span class="hljs-comment"># enable: false</span><br>  <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># Themes list:</span><br>  <span class="hljs-comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span><br>  <span class="hljs-comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span><br>  theme: minimal<br></code></pre></td></tr></table></figure><h3 id="4）配置进度条CDN地址"><a href="#4）配置进度条CDN地址" class="headerlink" title="4）配置进度条CDN地址"></a>4）配置进度条CDN地址</h3><p><strong>在NexT主题的<code>_config.xml</code>文件中找到<code>vendors</code>选项，设置pace的cdn地址（本人设置的进度条为黑色主题，可以在<a href="https://www.jsdelivr.com/package/npm/pace-js?path=themes" target="_blank" rel="noopener">jsdelivr</a>中找到对应的样式最新版cdn地址）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">vendors:<br>  ...<br>  pace: https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js<br>  pace_css: https://cdn.jsdelivr.net/npm/pace-js@1.0.2/themes/black/pace-theme-loading-bar.css<br></code></pre></td></tr></table></figure><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hexo版本&lt;/strong&gt;：4.2.0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NexT版本&lt;/strong&gt;：7.7.1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GitHub&lt;/strong&gt;：&lt;a href=&quot;https://github.com/theme-next/theme-next-pace&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;theme-next-pace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;各种进度条样式参考&lt;/strong&gt;：&lt;a href=&quot;https://blog.pangao.vip/Hexo博客NexT主题美化之顶部加载进度条/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo博客NexT主题美化之顶部加载进度条&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="个人博客搭建" scheme="https://tomandersen-cc.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Blog" scheme="https://tomandersen-cc.github.io/tags/Blog/"/>
    
      <category term="Hexo" scheme="https://tomandersen-cc.github.io/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://tomandersen-cc.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之NexT主题中设置canvas-nest特效</title>
    <link href="https://tomandersen-cc.github.io/2020/03/06/Hexo%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E4%B8%AD%E8%AE%BE%E7%BD%AEcanvas-nest%E7%89%B9%E6%95%88/"/>
    <id>https://tomandersen-cc.github.io/2020/03/06/Hexo%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E4%B8%AD%E8%AE%BE%E7%BD%AEcanvas-nest%E7%89%B9%E6%95%88/</id>
    <published>2020-03-06T03:06:19.000Z</published>
    <updated>2020-03-12T04:19:53.530Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>Hexo版本</strong>：4.2.0</li><li><strong>NexT版本</strong>：7.7.1</li><li><strong>NexT中集成有canvas_nest插件</strong></li><li><strong>GitHub</strong>：<a href="https://github.com/theme-next/theme-next-canvas-nest" target="_blank" rel="noopener">theme-next-canvas-nest</a></li><li><a href="https://git.hust.cc/canvas-nest.js" target="_blank" rel="noopener">canvas-nest特效展示</a></li></ul><a id="more"></a><hr><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><h3 id="1）配置NexT主题配置文件themes-next-config-yml"><a href="#1）配置NexT主题配置文件themes-next-config-yml" class="headerlink" title="1）配置NexT主题配置文件themes/next/_config.yml"></a>1）配置NexT主题配置文件<code>themes/next/_config.yml</code></h3><p><strong>a）开启canvas_nest</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Canvas-nest</span><br><span class="hljs-comment"># Dependencies: https://github.com/theme-next/theme-next-canvas-nest</span><br><span class="hljs-comment"># For more information: https://github.com/hustcc/canvas-nest.js</span><br><span class="hljs-comment"># 若要开启canvas_nest,除了此处设置成true,还需要设置canvas_nest的vendors提供商</span><br>canvas_nest:<br>  <span class="hljs-comment">#enable: false</span><br>  <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span><br>  onmobile: <span class="hljs-literal">true</span> <span class="hljs-comment"># Display on mobile or not</span><br>  color: <span class="hljs-string">"0,0,255"</span> <span class="hljs-comment"># RGB values, use `,` to separate</span><br>  opacity: 0.5 <span class="hljs-comment"># The opacity of line: 0~1</span><br>  zIndex: -1 <span class="hljs-comment"># z-index property of the background</span><br>  count: 99 <span class="hljs-comment"># The number of lines</span><br></code></pre></td></tr></table></figure><p><strong>b）设置canvas_nest脚本来源：在配置文件vendors选项下取消canvas_nest cdn注释</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Internal version: 1.0.0</span><br><span class="hljs-comment"># 设置canvas_nest的来源</span><br>canvas_nest: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js<br>canvas_nest_nomobile: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest-nomobile.min.js<br><span class="hljs-comment"># canvas_nest:</span><br><span class="hljs-comment"># canvas_nest_nomobile:</span><br></code></pre></td></tr></table></figure><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hexo版本&lt;/strong&gt;：4.2.0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NexT版本&lt;/strong&gt;：7.7.1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NexT中集成有canvas_nest插件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GitHub&lt;/strong&gt;：&lt;a href=&quot;https://github.com/theme-next/theme-next-canvas-nest&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;theme-next-canvas-nest&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://git.hust.cc/canvas-nest.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;canvas-nest特效展示&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="个人博客搭建" scheme="https://tomandersen-cc.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Blog" scheme="https://tomandersen-cc.github.io/tags/Blog/"/>
    
      <category term="Hexo" scheme="https://tomandersen-cc.github.io/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://tomandersen-cc.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>Hexo之NexT主题中设置symbols_count_time统计单词</title>
    <link href="https://tomandersen-cc.github.io/2020/03/06/Hexo%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E4%B8%AD%E8%AE%BE%E7%BD%AEsymbols-count-time%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D/"/>
    <id>https://tomandersen-cc.github.io/2020/03/06/Hexo%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E4%B8%AD%E8%AE%BE%E7%BD%AEsymbols-count-time%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D/</id>
    <published>2020-03-06T02:47:55.000Z</published>
    <updated>2020-03-12T04:19:58.303Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>Hexo版本</strong>：4.2.0</li><li><strong>NexT版本</strong>：7.7.1</li><li><strong>symbols_count_time</strong>能够统计页面或者站点的单词以及阅读所需时间</li><li>自NexT 6.0发行版之后第三方插件<strong>hexo-wordcount</strong>就被<strong>symbols_count_time</strong>取缔了，相比之下<strong>symbols_count_time</strong>没有额外的依赖，性能更加强大</li><li><strong>GitHub</strong>：<a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">symbols_count_time</a></li></ul><a id="more"></a><hr><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><h3 id="1）安装symbols-count-time插件"><a href="#1）安装symbols-count-time插件" class="headerlink" title="1）安装symbols_count_time插件"></a>1）安装symbols_count_time插件</h3><p><strong>在Hexo的根目录下安装symbols_count_time</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-symbols-count-time<br></code></pre></td></tr></table></figure><p><strong>若npm下载速度太慢可以使用淘宝npm镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g cnpm --registry=https://registry.npm.taobao.org<br>cnpm install hexo-symbols-count-time<br></code></pre></td></tr></table></figure><h3 id="2）配置Hexo站点配置文件-config-yml"><a href="#2）配置Hexo站点配置文件-config-yml" class="headerlink" title="2）配置Hexo站点配置文件_config.yml"></a>2）配置Hexo站点配置文件<code>_config.yml</code></h3><p><strong>在合适位置添加以下配置信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置博客单词统计</span><br>symbols_count_time:<br>  <span class="hljs-comment"># 文章字数统计</span><br>  symbols: <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 文章阅读时间统计</span><br>  time: <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 站点总字数统计</span><br>  total_symbols: <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># 站点总阅读时间统计</span><br>  total_time: <span class="hljs-literal">false</span><br>  exclude_codeblock: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="3）配置NexT主题配置文件themes-next-config-yml"><a href="#3）配置NexT主题配置文件themes-next-config-yml" class="headerlink" title="3）配置NexT主题配置文件themes/next/_config.yml"></a>3）配置NexT主题配置文件<code>themes/next/_config.yml</code></h3><p><strong>在symbols_count_time选下开启单词统计</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Post wordcount display settings</span><br><span class="hljs-comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span><br><span class="hljs-comment"># 设置博客单词统计</span><br>symbols_count_time:<br>  <span class="hljs-comment"># 是否另起一行（true的话不和发表时间等同一行）</span><br>  separated_meta: <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span><br>  item_text_post: <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span><br>  item_text_total: <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># 平均字长</span><br>  awl: 4<br>  <span class="hljs-comment"># 每分钟阅读字数</span><br>  wpm: 275<br></code></pre></td></tr></table></figure><h3 id="4）重新生成Hexo即可"><a href="#4）重新生成Hexo即可" class="headerlink" title="4）重新生成Hexo即可"></a>4）重新生成Hexo即可</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo s<br></code></pre></td></tr></table></figure><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hexo版本&lt;/strong&gt;：4.2.0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NexT版本&lt;/strong&gt;：7.7.1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;symbols_count_time&lt;/strong&gt;能够统计页面或者站点的单词以及阅读所需时间&lt;/li&gt;
&lt;li&gt;自NexT 6.0发行版之后第三方插件&lt;strong&gt;hexo-wordcount&lt;/strong&gt;就被&lt;strong&gt;symbols_count_time&lt;/strong&gt;取缔了，相比之下&lt;strong&gt;symbols_count_time&lt;/strong&gt;没有额外的依赖，性能更加强大&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GitHub&lt;/strong&gt;：&lt;a href=&quot;https://github.com/theme-next/hexo-symbols-count-time&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;symbols_count_time&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="个人博客搭建" scheme="https://tomandersen-cc.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Blog" scheme="https://tomandersen-cc.github.io/tags/Blog/"/>
    
      <category term="Hexo" scheme="https://tomandersen-cc.github.io/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://tomandersen-cc.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>Flume之使用Loadbalancing Sink Processor实现sink负载均衡</title>
    <link href="https://tomandersen-cc.github.io/2020/03/05/Flume%E4%B9%8B%E4%BD%BF%E7%94%A8Loadbalancing-Sink-Processor%E5%AE%9E%E7%8E%B0sink%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://tomandersen-cc.github.io/2020/03/05/Flume%E4%B9%8B%E4%BD%BF%E7%94%A8Loadbalancing-Sink-Processor%E5%AE%9E%E7%8E%B0sink%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2020-03-05T13:47:53.000Z</published>
    <updated>2020-03-08T13:45:30.748Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>Load balancing Sink Processor</strong>，顾名思义，即能够对Sink组中的每个Sink实现负载均衡，默认采用的是轮询<strong>round_robin</strong>的方式，还可以使用随机方式<strong>random</strong>，或者用户自己实现AbstractSinkSelector抽象类定义自己的Sink Selector类，并提供FQCN（Full Qualified Class Name）全类名来进行配置，并且Load balancing Sink Processor还提供了指数退避backoff，即当某个Sink挂掉时，将会将其加入到黑名单，一定时间内不再访问此Sink，退避时间呈指数增长并默认最大值为30000ms，可以手动设置</li></ul><hr><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="1）flume1-properties"><a href="#1）flume1-properties" class="headerlink" title="1）flume1.properties"></a>1）flume1.properties</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># flume1:此配置用于监控某个端口将其追加内容输出到flume2和flume3中</span><br><span class="hljs-comment"># 并将两个Sink组成一个sink group,并将Sink Processor设置成load_balance类型</span><br><span class="hljs-comment"># a1:Netcat Source-&gt; Memory Channel-&gt; Load balancing Sink Processor-&gt; Avro Sink</span><br><br><span class="hljs-comment"># Agent</span><br>a1.sources = r1<br>a1.channels = c1<br>a1.sinks = k1 k2<br><br><span class="hljs-comment"># Sink groups</span><br>a1.sinkgroups = g1<br><span class="hljs-comment"># 设置sink group中的sinks</span><br>a1.sinkgroups.g1.sinks = k1 k2<br><span class="hljs-comment"># 配置Load balancing Sink Processor(只有sink group才可以使用sink processor)</span><br>a1.sinkgroups.g1.processor.type = load_balance<br><span class="hljs-comment"># 设置开启指数避让</span><br>a1.sinkgroups.g1.processor.backoff = <span class="hljs-literal">true</span><br><span class="hljs-comment"># 设置Processor的selector为轮询round_robin</span><br>a1.sinkgroups.g1.processor.selector = round_robin<br><span class="hljs-comment"># 设置最大避让时间(ms)</span><br>a1.sinkgroups.g1.processor.maxTimeOut = 10000<br><br><br><span class="hljs-comment"># Sources</span><br><span class="hljs-comment"># 配置a1.sources.r1的各项属性参数,类型/绑定主机ip/端口号</span><br>a1.sources.r1.type = netcat<br>a1.sources.r1.bind = hadoop101<br>a1.sources.r1.port = 44444<br><br><span class="hljs-comment"># Channels</span><br><span class="hljs-comment"># 配置a1.channerls.c1的各项属性参数,缓存方式/最多缓存的Event个数/单次传输的Event个数</span><br>a1.channels.c1.type = memory<br>a1.channels.c1.capacity = 1000<br>a1.channels.c1.transactionCapacity = 100<br><br><span class="hljs-comment"># Sinks</span><br><span class="hljs-comment"># sinks.k1</span><br>a1.sinks.k1.type = avro<br>a1.sinks.k1.hostname = hadoop102<br>a1.sinks.k1.port = 4141<br><span class="hljs-comment"># sinks.k2</span><br>a1.sinks.k2.type = avro<br>a1.sinks.k2.hostname = hadoop103<br>a1.sinks.k2.port = 4141<br><br><span class="hljs-comment"># Bind</span><br><span class="hljs-comment"># 注意:source可以绑定多个channel,但是sink/sink group只能绑定单个channel</span><br><span class="hljs-comment"># r1-&gt;c1-&gt;g1</span><br>a1.sources.r1.channels = c1<br>a1.sinks.k1.channel = c1<br>a1.sinks.k2.channel = c1<br></code></pre></td></tr></table></figure><h3 id="2）flume2-properties"><a href="#2）flume2-properties" class="headerlink" title="2）flume2.properties"></a>2）flume2.properties</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># flume2:此配置用于将来自指定Avro端口的数据输出到控制台</span><br><span class="hljs-comment"># a2:Avro Source-&gt;Memory Channel-&gt;Logger Sink</span><br><br><span class="hljs-comment"># Agent</span><br>a2.sources = r1<br>a2.channels = c1<br>a2.sinks = k1<br><br><span class="hljs-comment"># Sources</span><br><span class="hljs-comment"># a2.sources.r1</span><br>a2.sources.r1.type = avro<br><span class="hljs-comment"># 设置监听本地IP</span><br>a2.sources.r1.bind = 0.0.0.0<br><span class="hljs-comment"># 设置监听端口号</span><br>a2.sources.r1.port = 4141<br><br><span class="hljs-comment"># Channels</span><br><span class="hljs-comment"># a2.channels.c1</span><br><span class="hljs-comment"># 使用内存作为缓存/最多缓存的Event个数/单次传输的Event个数</span><br>a2.channels.c1.type = memory<br>a2.channels.c1.capacity = 1000<br>a2.channels.c1.transactionCapacity = 100<br><br><span class="hljs-comment"># Sinks</span><br><span class="hljs-comment"># 运行时设置参数 -Dflume.root.logger=INFO,console 即输出到控制台实时显示</span><br>a2.sinks.k1.type = logger<br><span class="hljs-comment"># 设置Event的Body中写入log的最大字节数(默认值为16)</span><br>a2.sinks.k1.maxBytesToLog = 256<br><br><span class="hljs-comment"># Bind</span><br>a2.sources.r1.channels = c1<br>a2.sinks.k1.channel = c1<br></code></pre></td></tr></table></figure><h3 id="3）flume3-properties"><a href="#3）flume3-properties" class="headerlink" title="3）flume3.properties"></a>3）flume3.properties</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># flume3:此配置用于将来自指定Avro端口的数据输出到控制台</span><br><span class="hljs-comment"># a3:Avro Source-&gt;Memory Channel-&gt;Logger Sink</span><br><br><span class="hljs-comment"># Agent</span><br>a3.sources = r1<br>a3.channels = c1<br>a3.sinks = k1<br><br><span class="hljs-comment"># Sources</span><br><span class="hljs-comment"># a3.sources.r1</span><br>a3.sources.r1.type = avro<br><span class="hljs-comment"># 设置监听本地IP</span><br>a3.sources.r1.bind = 0.0.0.0<br><span class="hljs-comment"># 设置监听端口号</span><br>a3.sources.r1.port = 4141<br><br><span class="hljs-comment"># Channels</span><br><span class="hljs-comment"># a3.channels.c1</span><br><span class="hljs-comment"># 使用内存作为缓存/最多缓存的Event个数/单次传输的Event个数</span><br>a3.channels.c1.type = memory<br>a3.channels.c1.capacity = 1000<br>a3.channels.c1.transactionCapacity = 100<br><br><span class="hljs-comment"># Sinks</span><br><span class="hljs-comment"># 运行时设置参数 -Dflume.root.logger=INFO,console 即输出到控制台实时显示</span><br>a3.sinks.k1.type = logger<br><span class="hljs-comment"># 设置Event的Body中写入log的最大字节数(默认值为16)</span><br>a3.sinks.k1.maxBytesToLog = 256<br><br><span class="hljs-comment"># Bind</span><br>a3.sources.r1.channels = c1<br>a3.sinks.k1.channel = c1<br></code></pre></td></tr></table></figure><h3 id="4）对应功能"><a href="#4）对应功能" class="headerlink" title="4）对应功能"></a>4）对应功能</h3><p><strong>agent a1将指定端口的监听数据采用轮询的方式传输给a2和a3，并分别输出到各自的控制台</strong></p><h3 id="5）启动命令"><a href="#5）启动命令" class="headerlink" title="5）启动命令"></a>5）启动命令</h3><p><strong>Flume Agent a1至a3分别运行在主机hadoop101、hadoop102、hadoop103上</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./bin/flume-ng agent -n a1 -c conf -f flume1.properties<br>./bin/flume-ng agent -n a2 -c conf -f flume2.properties -Dflume.root.logger=INFO,console<br>./bin/flume-ng agent -n a3 -c conf -f flume3.properties -Dflume.root.logger=INFO,console<br></code></pre></td></tr></table></figure><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
      <category term="Flume" scheme="https://tomandersen-cc.github.io/categories/Flume/"/>
    
    
      <category term="Linux" scheme="https://tomandersen-cc.github.io/tags/Linux/"/>
    
      <category term="Flume" scheme="https://tomandersen-cc.github.io/tags/Flume/"/>
    
      <category term="大数据" scheme="https://tomandersen-cc.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Flume之使用Failover Sink Processor实现sink故障转移</title>
    <link href="https://tomandersen-cc.github.io/2020/03/05/Flume%E4%B9%8B%E4%BD%BF%E7%94%A8Failover-Sink-Processor%E5%AE%9E%E7%8E%B0sink%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/"/>
    <id>https://tomandersen-cc.github.io/2020/03/05/Flume%E4%B9%8B%E4%BD%BF%E7%94%A8Failover-Sink-Processor%E5%AE%9E%E7%8E%B0sink%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/</id>
    <published>2020-03-05T13:29:34.000Z</published>
    <updated>2020-03-08T13:45:11.295Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>Failover Sink Processor</strong> 维护着Sink组中Sinks的优先级表，根据优先级尝试将Event传输给不同的Sink直到Event成功发送。当优先级高的Sink不可用时，会将Event传输给下一优先级Sink，以此来确保每个Event都能被投递。当Sink不可用时，Failover Sink Processor和<strong>Load balancing Sink Processor</strong>一样，也会进行指数回退backoff，并可以设置最大回退时间（即在黑名单中的保存时间），在倒计时结束后会再次尝试访问之前挂掉的Sink</li></ul><hr><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="1）flume1-properties"><a href="#1）flume1-properties" class="headerlink" title="1）flume1.properties"></a>1）flume1.properties</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># flume1:此配置用于监控某个窗口将其追加内容输出到flume2和flume3中</span><br><span class="hljs-comment"># 并将两个Sink组成一个sink group,并将Sink Processor设置成Failover类型</span><br><span class="hljs-comment"># a1:Netcat Source-&gt;Memory Channel-&gt;Avro Sink</span><br><br><span class="hljs-comment"># Agent</span><br>a1.sources = r1<br>a1.channels = c1<br>a1.sinks = k1 k2<br><br><span class="hljs-comment"># Sink groups</span><br>a1.sinkgroups = g1<br><span class="hljs-comment"># 设置sink group中的sinks</span><br>a1.sinkgroups.g1.sinks = k1 k2<br><span class="hljs-comment"># 设置Failover sink processor(只有sink group才可以使用sink processor)</span><br>a1.sinkgroups.g1.processor.type = failover<br><span class="hljs-comment"># 设置Failover sink processor优先级表</span><br>a1.sinkgroups.g1.processor.priority.k1 = 5<br>a1.sinkgroups.g1.processor.priority.k2 = 10<br><span class="hljs-comment"># 设置最大避让时间(ms)</span><br>a1.sinkgroups.g1.processor.maxpenalty = 10000<br><br><br><span class="hljs-comment"># Sources</span><br><span class="hljs-comment"># 配置a1.sources.r1的各项属性参数,类型/绑定主机ip/端口号</span><br>a1.sources.r1.type = netcat<br>a1.sources.r1.bind = hadoop101<br>a1.sources.r1.port = 44444<br><br><span class="hljs-comment"># Channels</span><br><span class="hljs-comment"># 配置a1.channerls.c1的各项属性参数,缓存方式/最多缓存的Event个数/单次传输的Event个数</span><br>a1.channels.c1.type = memory<br>a1.channels.c1.capacity = 1000<br>a1.channels.c1.transactionCapacity = 100<br><br><span class="hljs-comment"># Sinks</span><br><span class="hljs-comment"># sinks.k1</span><br>a1.sinks.k1.type = avro<br>a1.sinks.k1.hostname = hadoop102<br>a1.sinks.k1.port = 4141<br><span class="hljs-comment"># sinks.k2</span><br>a1.sinks.k2.type = avro<br>a1.sinks.k2.hostname = hadoop103<br>a1.sinks.k2.port = 4141<br><br><span class="hljs-comment"># Bind</span><br><span class="hljs-comment"># 注意:source可以绑定多个channel,但是sink/sink group只能绑定单个channel</span><br><span class="hljs-comment"># r1-&gt;c1-&gt;g1</span><br>a1.sources.r1.channels = c1<br>a1.sinks.k1.channel = c1<br>a1.sinks.k2.channel = c1<br></code></pre></td></tr></table></figure><h3 id="2）flume2-properties"><a href="#2）flume2-properties" class="headerlink" title="2）flume2.properties"></a>2）flume2.properties</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># flume2:此配置用于将来自指定Avro端口的数据输出到控制台</span><br><span class="hljs-comment"># a2:Avro Source-&gt;Memory Channel-&gt;Logger Sink</span><br><br><span class="hljs-comment"># Agent</span><br>a2.sources = r1<br>a2.channels = c1<br>a2.sinks = k1<br><br><span class="hljs-comment"># Sources</span><br><span class="hljs-comment"># a2.sources.r1</span><br>a2.sources.r1.type = avro<br><span class="hljs-comment"># 设置监听本地IP</span><br>a2.sources.r1.bind = 0.0.0.0<br><span class="hljs-comment"># 设置监听端口号</span><br>a2.sources.r1.port = 4141<br><br><span class="hljs-comment"># Channels</span><br><span class="hljs-comment"># a2.channels.c1</span><br><span class="hljs-comment"># 使用内存作为缓存/最多缓存的Event个数/单次传输的Event个数</span><br>a2.channels.c1.type = memory<br>a2.channels.c1.capacity = 1000<br>a2.channels.c1.transactionCapacity = 100<br><br><span class="hljs-comment"># Sinks</span><br><span class="hljs-comment"># 运行时设置参数 -Dflume.root.logger=INFO,console 即输出到控制台实时显示</span><br>a2.sinks.k1.type = logger<br><span class="hljs-comment"># 设置Event的Body中写入log的最大字节数(默认值为16)</span><br>a2.sinks.k1.maxBytesToLog = 256<br><br><span class="hljs-comment"># Bind</span><br>a2.sources.r1.channels = c1<br>a2.sinks.k1.channel = c1<br></code></pre></td></tr></table></figure><h3 id="3）flume3-properties"><a href="#3）flume3-properties" class="headerlink" title="3）flume3.properties"></a>3）flume3.properties</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># flume3:此配置用于将来自指定Avro端口的数据输出到控制台</span><br><span class="hljs-comment"># a3:Avro Source-&gt;Memory Channel-&gt;Logger Sink</span><br><br><span class="hljs-comment"># Agent</span><br>a3.sources = r1<br>a3.channels = c1<br>a3.sinks = k1<br><br><span class="hljs-comment"># Sources</span><br><span class="hljs-comment"># a3.sources.r1</span><br>a3.sources.r1.type = avro<br><span class="hljs-comment"># 设置监听本地IP</span><br>a3.sources.r1.bind = 0.0.0.0<br><span class="hljs-comment"># 设置监听端口号</span><br>a3.sources.r1.port = 4141<br><br><span class="hljs-comment"># Channels</span><br><span class="hljs-comment"># a3.channels.c1</span><br><span class="hljs-comment"># 使用内存作为缓存/最多缓存的Event个数/单次传输的Event个数</span><br>a3.channels.c1.type = memory<br>a3.channels.c1.capacity = 1000<br>a3.channels.c1.transactionCapacity = 100<br><br><span class="hljs-comment"># Sinks</span><br><span class="hljs-comment"># 运行时设置参数 -Dflume.root.logger=INFO,console 即输出到控制台实时显示</span><br>a3.sinks.k1.type = logger<br><span class="hljs-comment"># 设置Event的Body中写入log的最大字节数(默认值为16)</span><br>a3.sinks.k1.maxBytesToLog = 256<br><br><span class="hljs-comment"># Bind</span><br>a3.sources.r1.channels = c1<br>a3.sinks.k1.channel = c1<br></code></pre></td></tr></table></figure><h3 id="4）对应功能"><a href="#4）对应功能" class="headerlink" title="4）对应功能"></a>4）对应功能</h3><ul><li><strong>Aent a1将指定端口的监听数据输出到a2或者a3的控制台</strong></li><li><strong>当Event从Channel中传输给Sink Group之前，首先会根据配置Failover sink processor优先级表尝试将此Event发送给优先级最高的可用Sink，如果成功则继续处理下一个Event。如果在发送过程中，当前Sink宕机，则将其加入黑名单，一定时间内不再尝试将Event发往此Sink，并且退避时间呈指数增长，直到最大退避时间maxpenalty，以此来实现Sink的故障转移</strong></li></ul><h3 id="5）启动命令"><a href="#5）启动命令" class="headerlink" title="5）启动命令"></a>5）启动命令</h3><p><strong>Flume Agent a1至a3分别运行在主机hadoop101、hadoop102、hadoop103上</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./bin/flume-ng agent -n a1 -c conf -f flume1.properties<br>./bin/flume-ng agent -n a2 -c conf -f flume2.properties -Dflume.root.logger=INFO,console<br>./bin/flume-ng agent -n a3 -c conf -f flume3.properties -Dflume.root.logger=INFO,console<br></code></pre></td></tr></table></figure><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
      <category term="Flume" scheme="https://tomandersen-cc.github.io/categories/Flume/"/>
    
    
      <category term="Linux" scheme="https://tomandersen-cc.github.io/tags/Linux/"/>
    
      <category term="Flume" scheme="https://tomandersen-cc.github.io/tags/Flume/"/>
    
      <category term="大数据" scheme="https://tomandersen-cc.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Flume之Multiplexing Channel Selector使用示例</title>
    <link href="https://tomandersen-cc.github.io/2020/03/05/Flume%E4%B9%8BMultiplexing-Channel-Selector%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
    <id>https://tomandersen-cc.github.io/2020/03/05/Flume%E4%B9%8BMultiplexing-Channel-Selector%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</id>
    <published>2020-03-05T12:58:33.000Z</published>
    <updated>2020-03-08T13:46:57.911Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><strong>Multiplexing Channe Selector</strong> 的作用就是根据 <strong>Event</strong> 的 <strong>Header</strong> 中的某个或几个字段的值将其映射到指定的 <strong>Channel</strong> ，便于之后 <strong>Channel Processor</strong> 将Event发送至对应的Channel中去。在Flume中，Multiplexing Channel Selector一般都与 <strong>Interceptor</strong> 拦截器搭配使用，因为新鲜的Event数据中Header为空，需要Interceptor去填充所需字段</li></ul><hr><h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><h3 id="1）flume1-properties"><a href="#1）flume1-properties" class="headerlink" title="1）flume1.properties"></a>1）flume1.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># flume1:此配置用于监控单个或多个指定文件将其追加内容生成的Event先通过自定义的TypeInterceptor</span><br><span class="hljs-comment"># 根据Body中的内容向其Header中添加type字段,然后使用Multiplexing Channel Selector将不同</span><br><span class="hljs-comment"># type的Event传输到不同的Channel中,最后分别输出到flume2和flume3的控制台</span><br><span class="hljs-comment"># a1:TailDir Source-&gt; TypeInterceptor -&gt; Multiplexing Channel Selector -&gt;</span><br><span class="hljs-comment">#   Memory Channel -&gt; Avro Sink</span><br><span class="hljs-comment"><br># Agent</span><br><span class="hljs-meta">a1.sources</span> = <span class="hljs-string">r1</span><br><span class="hljs-meta">a1.channels</span> = <span class="hljs-string">c1 c2</span><br><span class="hljs-meta">a1.sinks</span> = <span class="hljs-string">k1 k2</span><br><span class="hljs-comment"><br># Sources</span><br><span class="hljs-comment"># a1.sources.r1</span><br><span class="hljs-meta">a1.sources.r1.type</span> = <span class="hljs-string">TAILDIR</span><br><span class="hljs-comment"># 设置Json文件存储路径(最好使用绝对路径)</span><br><span class="hljs-comment"># 用于记录文件inode/文件的绝对路径/每个文件的最后读取位置等信息</span><br><span class="hljs-meta">a1.sources.r1.positionFile</span> = <span class="hljs-string">/opt/module/flume-1.8.0/.position/taildir_position.json</span><br><span class="hljs-comment"># 指定监控的文件组</span><br><span class="hljs-meta">a1.sources.r1.filegroups</span> = <span class="hljs-string">f1</span><br><span class="hljs-comment"># 配置文件组中的被监控文件</span><br><span class="hljs-comment"># 设置f2组的监控文件,注意:使用的是正则表达式,而不是Linux通配符</span><br><span class="hljs-meta">a1.sources.r1.filegroups.f1</span> = <span class="hljs-string">/tmp/logs/^.*log$</span><br><span class="hljs-comment"><br># Interceptor</span><br><span class="hljs-comment"># a1.sources.r1.interceptors</span><br><span class="hljs-comment"># 配置Interceptor链,Interceptor调用顺序与配置循序相同</span><br><span class="hljs-meta">a1.sources.r1.interceptors</span> = <span class="hljs-string">typeInterceptor</span><br><span class="hljs-comment"># 指定使用的自定义Interceptor全类名,并使用其中的静态内部类Builder</span><br><span class="hljs-comment"># 要想使用自定义Interceptor,必须将实现的类打包成jar包放入$FLUME_HOME/lib文件夹中</span><br><span class="hljs-comment"># flume运行Java程序时会将此路径加入到ClassPath中</span><br><span class="hljs-meta">a1.sources.r1.interceptors.typeInterceptor.type</span> = <span class="hljs-string">com.tomandersen.interceptors.TypeInterceptor$Builder</span><br><span class="hljs-comment"><br># Channels</span><br><span class="hljs-comment"># a1.channels.c1</span><br><span class="hljs-comment"># 使用内存作为缓存/最多缓存的Event个数/单次传输的Event个数</span><br><span class="hljs-meta">a1.channels.c1.type</span> = <span class="hljs-string">memory</span><br><span class="hljs-meta">a1.channels.c1.capacity</span> = <span class="hljs-string">1000</span><br><span class="hljs-meta">a1.channels.c1.transactionCapacity</span> = <span class="hljs-string">100</span><br><span class="hljs-comment"># a1.channels.c2</span><br><span class="hljs-meta">a1.channels.c2.type</span> = <span class="hljs-string">memory</span><br><span class="hljs-meta">a1.channels.c2.capacity</span> = <span class="hljs-string">1000</span><br><span class="hljs-meta">a1.channels.c2.transactionCapacity</span> = <span class="hljs-string">100</span><br><span class="hljs-comment"><br># Channel Selector</span><br><span class="hljs-comment"># a1.sources.r1.selector</span><br><span class="hljs-comment"># 使用Multiple Channel Selector</span><br><span class="hljs-meta">a1.sources.r1.selector.type</span> = <span class="hljs-string">multiplexing</span><br><span class="hljs-comment"># 设置匹配Header的字段</span><br><span class="hljs-meta">a1.sources.r1.selector.header</span> = <span class="hljs-string">type</span><br><span class="hljs-comment"># 设置不同字段的值映射至各个Channel,其余的Event默认丢弃</span><br><span class="hljs-meta">a1.sources.r1.selector.mapping.Startup</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sources.r1.selector.mapping.Event</span> = <span class="hljs-string">c2</span><br><span class="hljs-comment"><br># Sinks</span><br><span class="hljs-comment"># a1.sinks.k1</span><br><span class="hljs-meta">a1.sinks.k1.type</span> = <span class="hljs-string">avro</span><br><span class="hljs-meta">a1.sinks.k1.hostname</span> = <span class="hljs-string">hadoop102</span><br><span class="hljs-meta">a1.sinks.k1.port</span> = <span class="hljs-string">4141</span><br><span class="hljs-comment"># a1.sinks.k2</span><br><span class="hljs-meta">a1.sinks.k2.type</span> = <span class="hljs-string">avro</span><br><span class="hljs-meta">a1.sinks.k2.hostname</span> = <span class="hljs-string">hadoop103</span><br><span class="hljs-meta">a1.sinks.k2.port</span> = <span class="hljs-string">4141</span><br><span class="hljs-comment"><br># Bind</span><br><span class="hljs-comment"># r1-&gt;TypeInterceptor-&gt;Multiplexing Channel Selector-&gt;c1-&gt;k1</span><br><span class="hljs-comment"># r1-&gt;TypeInterceptor-&gt;Multiplexing Channel Selector-&gt;c2-&gt;k2</span><br><span class="hljs-meta">a1.sources.r1.channels</span> = <span class="hljs-string">c1 c2</span><br><span class="hljs-meta">a1.sinks.k1.channel</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a1.sinks.k2.channel</span> = <span class="hljs-string">c2</span><br></code></pre></td></tr></table></figure><h3 id="2）flume2-properties"><a href="#2）flume2-properties" class="headerlink" title="2）flume2.properties"></a>2）flume2.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># flume2:此配置用于将来自指定Avro端口的数据输出到控制台中</span><br><span class="hljs-comment"># a2:Avro Source-&gt;Memory Channel-&gt;Logger Sink</span><br><span class="hljs-comment"><br># Agent</span><br><span class="hljs-meta">a2.sources</span> = <span class="hljs-string">r1</span><br><span class="hljs-meta">a2.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a2.sinks</span> = <span class="hljs-string">k1</span><br><span class="hljs-comment"><br># Sources</span><br><span class="hljs-meta">a2.sources.r1.type</span> = <span class="hljs-string">avro</span><br><span class="hljs-meta">a2.sources.r1.bind</span> = <span class="hljs-string">0.0.0.0</span><br><span class="hljs-meta">a2.sources.r1.port</span> = <span class="hljs-string">4141</span><br><span class="hljs-comment"><br># Channels</span><br><span class="hljs-meta">a2.channels.c1.type</span> = <span class="hljs-string">memory</span><br><span class="hljs-meta">a2.channels.c1.capacity</span> = <span class="hljs-string">1000</span><br><span class="hljs-meta">a2.channels.c1.transactionCapacity</span> = <span class="hljs-string">100</span><br><span class="hljs-comment"><br># Sinks</span><br><span class="hljs-comment"># 运行时设置参数 -Dflume.root.logger=INFO,console 即输出到控制台实时显示</span><br><span class="hljs-meta">a2.sinks.k1.type</span> = <span class="hljs-string">logger</span><br><span class="hljs-comment"># 设置Event的Body中写入log的最大字节数(默认值为16)</span><br><span class="hljs-meta">a2.sinks.k1.maxBytesToLog</span> = <span class="hljs-string">256</span><br><span class="hljs-comment"><br># Bind</span><br><span class="hljs-attr">r1-&gt;c1-&gt;k1</span><br><span class="hljs-meta">a2.sources.r1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a2.sinks.k1.channel</span> = <span class="hljs-string">c1</span><br></code></pre></td></tr></table></figure><h3 id="3）flume3-properties"><a href="#3）flume3-properties" class="headerlink" title="3）flume3.properties"></a>3）flume3.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># flume3:此配置用于将来自指定Avro端口的数据输出到控制台中</span><br><span class="hljs-comment"># a3:Avro Source-&gt;Memory Channel-&gt;Logger Sink</span><br><span class="hljs-comment"><br># Agent</span><br><span class="hljs-meta">a3.sources</span> = <span class="hljs-string">r1</span><br><span class="hljs-meta">a3.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a3.sinks</span> = <span class="hljs-string">k1</span><br><span class="hljs-comment"><br># Sources</span><br><span class="hljs-meta">a3.sources.r1.type</span> = <span class="hljs-string">avro</span><br><span class="hljs-meta">a3.sources.r1.bind</span> = <span class="hljs-string">0.0.0.0</span><br><span class="hljs-meta">a3.sources.r1.port</span> = <span class="hljs-string">4141</span><br><span class="hljs-comment"><br># Channels</span><br><span class="hljs-meta">a3.channels.c1.type</span> = <span class="hljs-string">memory</span><br><span class="hljs-meta">a3.channels.c1.capacity</span> = <span class="hljs-string">1000</span><br><span class="hljs-meta">a3.channels.c1.transactionCapacity</span> = <span class="hljs-string">100</span><br><span class="hljs-comment"><br># Sinks</span><br><span class="hljs-comment"># 运行时设置参数 -Dflume.root.logger=INFO,console 即输出到控制台实时显示</span><br><span class="hljs-meta">a3.sinks.k1.type</span> = <span class="hljs-string">logger</span><br><span class="hljs-comment"># 设置Event的Body中写入log的最大字节数(默认值为16)</span><br><span class="hljs-meta">a3.sinks.k1.maxBytesToLog</span> = <span class="hljs-string">256</span><br><span class="hljs-comment"><br># Bind</span><br><span class="hljs-attr">r1-&gt;c1-&gt;k1</span><br><span class="hljs-meta">a3.sources.r1.channels</span> = <span class="hljs-string">c1</span><br><span class="hljs-meta">a3.sinks.k1.channel</span> = <span class="hljs-string">c1</span><br></code></pre></td></tr></table></figure><h3 id="4）对应功能"><a href="#4）对应功能" class="headerlink" title="4）对应功能"></a>4）对应功能</h3><p><strong>Agent a1监听本地指定文件,将监听到的数据组装成Event通过自定义的 TypeInterceptor 来根据其Body中的内容向Header中添加不同的type字段键值，然后通过 Multiplexing Channel Selector将不同type的Event发送给不同的Channel，并最终分别在a2和a3的控制台上输出</strong></p><h3 id="5）启动命令"><a href="#5）启动命令" class="headerlink" title="5）启动命令"></a>5）启动命令</h3><p><strong>Agent a1至a3分别运行在主机hadoop101、hadoop102、hadoop103上</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./bin/flume-ng agent -n a1 -c conf -f flume1.properties<br>./bin/flume-ng agent -n a2 -c conf -f flume2.properties -Dflume.root.logger=INFO,console<br>./bin/flume-ng agent -n a3 -c conf -f flume3.properties -Dflume.root.logger=INFO,console<br></code></pre></td></tr></table></figure><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
      <category term="Flume" scheme="https://tomandersen-cc.github.io/categories/Flume/"/>
    
    
      <category term="Linux" scheme="https://tomandersen-cc.github.io/tags/Linux/"/>
    
      <category term="Flume" scheme="https://tomandersen-cc.github.io/tags/Flume/"/>
    
      <category term="大数据" scheme="https://tomandersen-cc.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="HDFS" scheme="https://tomandersen-cc.github.io/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>Flume之实现和使用自定义Interceptor</title>
    <link href="https://tomandersen-cc.github.io/2020/03/05/Flume%E4%B9%8B%E5%AE%9E%E7%8E%B0%E5%92%8C%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89Interceptor/"/>
    <id>https://tomandersen-cc.github.io/2020/03/05/Flume%E4%B9%8B%E5%AE%9E%E7%8E%B0%E5%92%8C%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89Interceptor/</id>
    <published>2020-03-05T12:41:52.000Z</published>
    <updated>2020-03-08T13:45:07.214Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>Flume Interceptor拦截器的作用在于能够在Event从Source传输到Channel过程中，修改或者删除Event的Header。多个拦截器Interceptor组成一个拦截器链，拦截器的执行顺序与配置顺序相同，上一个拦截器Interceptor处理后的Event List会传给下一个Interceptor</li><li>在Flume中自定义Interceptor时，需要实现org.apache.flume.interceptor.Interceptor接口，以及创建静态内部类去实现org.apache.flume.interceptor.Interceptor.Builder接口</li><li>更多详细内容可以参考《Flume构建高可用、可扩展的海量日志采集系统》</li></ul><hr><h2 id="实现自定义Interceptor拦截器"><a href="#实现自定义Interceptor拦截器" class="headerlink" title="实现自定义Interceptor拦截器"></a>实现自定义Interceptor拦截器</h2><h3 id="1）根据使用场景创建Interceptor类"><a href="#1）根据使用场景创建Interceptor类" class="headerlink" title="1）根据使用场景创建Interceptor类"></a>1）根据使用场景创建Interceptor类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br><br>    <span class="hljs-comment">// 初始化时可以不做操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// Do nothing</span><br>    &#125;<br><br>    <span class="hljs-comment">// 单个Event拦截</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Event <span class="hljs-title">intercept</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Event event)</span> </span>&#123;<br>        <span class="hljs-comment">// 1.获取Event中的Header</span><br>        Map&lt;String, String&gt; headers = event.getHeaders();<br><br>        <span class="hljs-comment">// 2.获取Event中的Body,将其转换成字符串String</span><br>        String body = <span class="hljs-keyword">new</span> String(event.getBody());<br><br>        <span class="hljs-comment">// 3.根据Body中数据向Header添加键值对,表明日志类型</span><br>        <span class="hljs-keyword">if</span> (body.contains(<span class="hljs-string">"cm"</span>)) &#123;<br>            <span class="hljs-comment">// 4.添加Header信息</span><br>            headers.put(<span class="hljs-string">"type"</span>, <span class="hljs-string">"Startup"</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 4.添加Header信息</span><br>            headers.put(<span class="hljs-string">"type"</span>, <span class="hljs-string">"Event"</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> event;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 批量Event拦截</span><br>    <span class="hljs-comment">// 注意:既可以原Event集合进行修改,也可以创建新的Event集合作为成员变量,将此成员变量返回</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Event&gt; <span class="hljs-title">intercept</span><span class="hljs-params">(<span class="hljs-keyword">final</span> List&lt;Event&gt; events)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Event event : events) &#123;<br>            <span class="hljs-comment">// 1.对每个Event采用单个Event拦截的方式进行处理,忽略其返回值</span><br>            intercept(event);<br>        &#125;<br>        <span class="hljs-comment">// 2.返回处理结果</span><br>        <span class="hljs-keyword">return</span> events;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 关闭时可以不作操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// Do nothing</span><br>    &#125;<br><br><br>    <span class="hljs-comment">// 创建静态内部类实现Interceptor.Builder接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span>.<span class="hljs-title">Builder</span> </span>&#123;<br><br>        <span class="hljs-comment">// 定义配置信息</span><br>        <span class="hljs-keyword">private</span> Context context;<br><br>        <span class="hljs-comment">// 定义Interceptor生成器</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Interceptor <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TypeInterceptor();<br>        &#125;<br><br>        <span class="hljs-comment">// 获取配置信息</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.context = context;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）将此Interceptor类打包，并将jar包放入flume-lib路径下"><a href="#2）将此Interceptor类打包，并将jar包放入flume-lib路径下" class="headerlink" title="2）将此Interceptor类打包，并将jar包放入flume/lib路径下"></a>2）将此Interceptor类打包，并将jar包放入<code>flume/lib</code>路径下</h3><p><strong>此路径在Flume运行时的ClassPath中，因而可以在flume配置文件中可以通过全类名指定使用的Interceptor.Builder类</strong></p><p><strong>Maven项目打包插件配置可以参考：</strong><a href="https://blog.csdn.net/TomAndersen/article/details/104245064" target="_blank" rel="noopener">《IDEA中配置Maven项目打包插件》</a></p><hr><h2 id="创建flume-Agent配置文件"><a href="#创建flume-Agent配置文件" class="headerlink" title="创建flume Agent配置文件"></a>创建flume Agent配置文件</h2><h3 id="1）flume1-properties"><a href="#1）flume1-properties" class="headerlink" title="1）flume1.properties"></a>1）flume1.properties</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># flume1:此配置用于监控单个或多个指定文件将其追加内容先通过自定义的TypeInterceptor</span><br><span class="hljs-comment"># 向Header中添加type字段,然后使用Multiplexing Channel Selector将不同type的Event</span><br><span class="hljs-comment"># 传输到不同的Channel中,最后分别输出到flume2和flume3的控制台</span><br><span class="hljs-comment"># a1:TailDir Source-&gt; TypeInterceptor -&gt; Multiplexing Channel Selector -&gt;</span><br><span class="hljs-comment">#   Memory Channel -&gt; Avro Sink</span><br><br><span class="hljs-comment"># Agent</span><br>a1.sources = r1<br>a1.channels = c1 c2<br>a1.sinks = k1 k2<br><br><span class="hljs-comment"># Sources</span><br><span class="hljs-comment"># a1.sources.r1</span><br>a1.sources.r1.type = TAILDIR<br><span class="hljs-comment"># 设置Json文件存储路径(最好使用绝对路径)</span><br><span class="hljs-comment"># 用于记录文件inode/文件的绝对路径/每个文件的最后读取位置等信息</span><br>a1.sources.r1.positionFile = /opt/module/flume-1.8.0/.position/taildir_position.json<br><span class="hljs-comment"># 指定监控的文件组</span><br>a1.sources.r1.filegroups = f1<br><span class="hljs-comment"># 配置文件组中的被监控文件</span><br><span class="hljs-comment"># 设置f2组的监控文件,注意:使用的是正则表达式,而不是Linux通配符</span><br>a1.sources.r1.filegroups.f1 = /tmp/logs/^.*<span class="hljs-built_in">log</span>$<br><br><span class="hljs-comment"># Interceptor</span><br><span class="hljs-comment"># a1.sources.r1.interceptors</span><br><span class="hljs-comment"># 配置Interceptor链,Interceptor调用顺序与配置循序相同</span><br>a1.sources.r1.interceptors = typeInterceptor<br><span class="hljs-comment"># 指定使用的自定义Interceptor全类名,并使用其中的静态内部类Builder</span><br><span class="hljs-comment"># 要想使用自定义Interceptor,必须将实现的类打包成jar包放入$FLUME_HOME/lib文件夹中</span><br><span class="hljs-comment"># flume运行Java程序时会将此路径加入到ClassPath中</span><br>a1.sources.r1.interceptors.typeInterceptor.type = com.tomandersen.interceptors.TypeInterceptor<span class="hljs-variable">$Builder</span><br><br><span class="hljs-comment"># Channels</span><br><span class="hljs-comment"># a1.channels.c1</span><br><span class="hljs-comment"># 使用内存作为缓存/最多缓存的Event个数/单次传输的Event个数</span><br>a1.channels.c1.type = memory<br>a1.channels.c1.capacity = 1000<br>a1.channels.c1.transactionCapacity = 100<br><span class="hljs-comment"># a1.channels.c2</span><br>a1.channels.c2.type = memory<br>a1.channels.c2.capacity = 1000<br>a1.channels.c2.transactionCapacity = 100<br><br><span class="hljs-comment"># Channel Selector</span><br><span class="hljs-comment"># a1.sources.r1.selector</span><br><span class="hljs-comment"># 使用Multiple Channel Selector</span><br>a1.sources.r1.selector.type = multiplexing<br><span class="hljs-comment"># 设置匹配Header的字段</span><br>a1.sources.r1.selector.header = <span class="hljs-built_in">type</span><br><span class="hljs-comment"># 设置不同字段的值映射至各个Channel,其余的Event默认丢弃</span><br>a1.sources.r1.selector.mapping.Startup = c1<br>a1.sources.r1.selector.mapping.Event = c2<br><br><span class="hljs-comment"># Sinks</span><br><span class="hljs-comment"># a1.sinks.k1</span><br>a1.sinks.k1.type = avro<br>a1.sinks.k1.hostname = hadoop102<br>a1.sinks.k1.port = 4141<br><span class="hljs-comment"># a1.sinks.k2</span><br>a1.sinks.k2.type = avro<br>a1.sinks.k2.hostname = hadoop103<br>a1.sinks.k2.port = 4141<br><br><span class="hljs-comment"># Bind</span><br><span class="hljs-comment"># r1-&gt;TypeInterceptor-&gt;Multiplexing Channel Selector-&gt;c1-&gt;k1</span><br><span class="hljs-comment"># r1-&gt;TypeInterceptor-&gt;Multiplexing Channel Selector-&gt;c2-&gt;k2</span><br>a1.sources.r1.channels = c1 c2<br>a1.sinks.k1.channel = c1<br>a1.sinks.k2.channel = c2<br></code></pre></td></tr></table></figure><h3 id="2）flume2-properties"><a href="#2）flume2-properties" class="headerlink" title="2）flume2.properties"></a>2）flume2.properties</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># flume2:此配置用于将来自指定Avro端口的数据输出到控制台中</span><br><span class="hljs-comment"># a2:Avro Source-&gt;Memory Channel-&gt;Logger Sink</span><br><br><span class="hljs-comment"># Agent</span><br>a2.sources = r1<br>a2.channels = c1<br>a2.sinks = k1<br><br><span class="hljs-comment"># Sources</span><br>a2.sources.r1.type = avro<br>a2.sources.r1.bind = 0.0.0.0<br>a2.sources.r1.port = 4141<br><br><span class="hljs-comment"># Channels</span><br>a2.channels.c1.type = memory<br>a2.channels.c1.capacity = 1000<br>a2.channels.c1.transactionCapacity = 100<br><br><span class="hljs-comment"># Sinks</span><br><span class="hljs-comment"># 运行时设置参数 -Dflume.root.logger=INFO,console 即输出到控制台实时显示</span><br>a2.sinks.k1.type = logger<br><span class="hljs-comment"># 设置Event的Body中写入log的最大字节数(默认值为16)</span><br>a2.sinks.k1.maxBytesToLog = 256<br><br><span class="hljs-comment"># Bind</span><br>r1-&gt;c1-&gt;k1<br>a2.sources.r1.channels = c1<br>a2.sinks.k1.channel = c1<br></code></pre></td></tr></table></figure><h3 id="3）flume3-properties"><a href="#3）flume3-properties" class="headerlink" title="3）flume3.properties"></a>3）flume3.properties</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># flume3:此配置用于将来自指定Avro端口的数据输出到控制台中</span><br><span class="hljs-comment"># a3:Avro Source-&gt;Memory Channel-&gt;Logger Sink</span><br><br><span class="hljs-comment"># Agent</span><br>a3.sources = r1<br>a3.channels = c1<br>a3.sinks = k1<br><br><span class="hljs-comment"># Sources</span><br>a3.sources.r1.type = avro<br>a3.sources.r1.bind = 0.0.0.0<br>a3.sources.r1.port = 4141<br><br><span class="hljs-comment"># Channels</span><br>a3.channels.c1.type = memory<br>a3.channels.c1.capacity = 1000<br>a3.channels.c1.transactionCapacity = 100<br><br><span class="hljs-comment"># Sinks</span><br><span class="hljs-comment"># 运行时设置参数 -Dflume.root.logger=INFO,console 即输出到控制台实时显示</span><br>a3.sinks.k1.type = logger<br><span class="hljs-comment"># 设置Event的Body中写入log的最大字节数(默认值为16)</span><br>a3.sinks.k1.maxBytesToLog = 256<br><br><span class="hljs-comment"># Bind</span><br>r1-&gt;c1-&gt;k1<br>a3.sources.r1.channels = c1<br>a3.sinks.k1.channel = c1<br></code></pre></td></tr></table></figure><h3 id="4）对应功能"><a href="#4）对应功能" class="headerlink" title="4）对应功能"></a>4）对应功能</h3><p><strong>Flume Agent a1监听本地指定文件,将监听到的数据组装成Event通过自定义的 TypeInterceptor 来根据其Body中的内容向Header中添加不同的type字段键值，然后通过 Multiplexing Channel Selector将不同type的Event发送给不同的Channel，并最终分别在Flume Agent a2和a3的控制台上输出</strong></p><h3 id="5）启动命令"><a href="#5）启动命令" class="headerlink" title="5）启动命令"></a>5）启动命令</h3><p><strong>Flume Agent a1至a3分别运行在主机hadoop101、hadoop102、hadoop103上</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./bin/flume-ng agent -n a1 -c conf -f flume1.properties<br>./bin/flume-ng agent -n a2 -c conf -f flume2.properties -Dflume.root.logger=INFO,console<br>./bin/flume-ng agent -n a3 -c conf -f flume3.properties -Dflume.root.logger=INFO,console<br></code></pre></td></tr></table></figure><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
      <category term="Flume" scheme="https://tomandersen-cc.github.io/categories/Flume/"/>
    
    
      <category term="Linux" scheme="https://tomandersen-cc.github.io/tags/Linux/"/>
    
      <category term="Flume" scheme="https://tomandersen-cc.github.io/tags/Flume/"/>
    
      <category term="大数据" scheme="https://tomandersen-cc.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Maven之子模块pom.xml继承父模块pom.xml配置</title>
    <link href="https://tomandersen-cc.github.io/2020/03/05/Maven%E4%B9%8B%E5%AD%90%E6%A8%A1%E5%9D%97pom-xml%E7%BB%A7%E6%89%BF%E7%88%B6%E6%A8%A1%E5%9D%97pom-xml%E9%85%8D%E7%BD%AE/"/>
    <id>https://tomandersen-cc.github.io/2020/03/05/Maven%E4%B9%8B%E5%AD%90%E6%A8%A1%E5%9D%97pom-xml%E7%BB%A7%E6%89%BF%E7%88%B6%E6%A8%A1%E5%9D%97pom-xml%E9%85%8D%E7%BD%AE/</id>
    <published>2020-03-05T12:17:42.000Z</published>
    <updated>2020-03-06T12:11:10.228Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Maven中可以通过继承父模块pom，来实现pom.xml配置的继承和传递，便于各种Maven插件以及程序依赖的统一管理。通过将子类模块的公共配置，抽象聚合生成父类模块，能够避免pom.xml的重复配置。由于父类模块本身并不包含除了POM之外的项目文件，也就不需要src/main/java之类的文件夹了。每当需要对多个子模块进行相同的配置时，只需要在父类模块的pom中进行配置，而子类中声明使用此配置即可，当然子类pom中也可以自定义配置，并覆盖父类中的各项配置，和Java中类的继承类似。</p><hr><h2 id="可继承的POM元素"><a href="#可继承的POM元素" class="headerlink" title="可继承的POM元素"></a>可继承的POM元素</h2><p><strong>1) <code>groupId</code>：项目组ID，项目坐标的核心元素</strong></p><p><strong>2) <code>version</code>：项目版本，项目坐标的核心元素</strong></p><p><strong>3) <code>description</code>：项目的表述信息</strong></p><p><strong>4) <code>organization</code>：项目的组织信息</strong></p><p><strong>5) <code>inception Year</code>：项目的创始年份</strong></p><p><strong>6) <code>url</code>：项目的URL地址</strong></p><p><strong>7) <code>developers</code>：项目的开发者信息</strong></p><p><strong>8) <code>contributors</code>：项目的贡献者信息</strong></p><p><strong>9) <code>distributionManagement</code>：项目的部署管理</strong></p><p><strong>10) <code>issueManagement</code>：项目的缺陷和跟踪系统信息</strong></p><p><strong>11) <code>ciManagement</code>：项目的持续集成信息系统</strong></p><p><strong>12) <code>scm</code>：项目的版本控制系统信息</strong></p><p><strong>13) <code>mailingLists</code>：项目的邮件列表信息</strong></p><p><strong>14) <code>properties</code>：自定义的Maven属性</strong></p><p><strong>15) <code>dependencies</code>：项目的依赖属性</strong></p><p><strong>16) <code>dependencyManagement</code>：项目的依赖管理配置</strong></p><p><strong>17) <code>repositories</code>：项目的仓库配置</strong></p><p><strong>18) <code>build</code>：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等</strong></p><p><strong>19) <code>reporting</code>：包括项目的报告输出目录配置、报告插件配置等</strong></p><hr><h2 id="POM继承中的依赖管理和插件管理"><a href="#POM继承中的依赖管理和插件管理" class="headerlink" title="POM继承中的依赖管理和插件管理"></a>POM继承中的依赖管理和插件管理</h2><p>Maven提供的<code>dependencyManagement</code>和<code>pluginManagement</code>元素用于帮助POM继承过程中的依赖管理和插件管理。在父类POM下，此两个元素中的声明的依赖或配置并不会引入实际的依赖或是造成实际的插件调用行为，不过它们能够约束子类POM中的依赖和插件配置的声明。只有当子类POM中配置了真正的<code>dependency</code>或<code>plugin</code>，并且其<code>groupId</code>和<code>artifactId</code>与父类POM中<code>dependencyManagement</code>和<code>pluginManagement</code>相对应时，才会进行实际的依赖引入或插件调用，当然子类中也能够进行自定义配置去覆盖父类，或是额外声明自己的配置</p><hr><h2 id="POM继承示例"><a href="#POM继承示例" class="headerlink" title="POM继承示例"></a>POM继承示例</h2><p><strong>1) 在父类POM中使用<code>dependencyManagement</code>和<code>pluginManagement</code>，声明子类POM中可能用到的依赖和插件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tomandersen<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>HadoopCustomModules<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>flume<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>log-collector<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--事先声明版本属性--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slf4j.version</span>&gt;</span>1.7.20<span class="hljs-tag">&lt;/<span class="hljs-name">slf4j.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logback.version</span>&gt;</span>1.0.7<span class="hljs-tag">&lt;/<span class="hljs-name">logback.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!--在父类Maven中使用dependencyManagement声明依赖便于子类Module继承使用,也便于进行依赖版本控制--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--阿里巴巴开源json解析框架--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.51<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--日志生成框架--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;logback.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;logback.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--在父类Maven中使用pluginManagement管理插件便于子类Module继承使用,也便于进行依赖版本控制--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--Maven项目编译器compiler插件--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!--Maven项目汇编assembly插件--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">descriptorRefs</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">descriptorRef</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">descriptorRefs</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">archive</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br>                            <span class="hljs-comment">&lt;!--子类Maven通过mainClass标签设置成主类的全类名FQCN--&gt;</span><br>                            <span class="hljs-comment">&lt;!--&lt;mainClass&gt;&lt;/mainClass&gt;--&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">archive</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>make-assembly<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>single<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2) 在子类POM中声明父类POM，并配置实际使用的<code>dependency</code>和<code>plugin</code>，只需要通过声明<code>groupId</code>和<code>artifactId</code>就可以避免配置各种依赖和插件的详细配置，当然也可以自己覆盖父类配置信息</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--声明父类POM--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>HadoopCustomModules<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tomandersen<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><span class="hljs-comment">&lt;!--子类POM信息--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.tomandersen<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log-collector<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--阿里巴巴开源json解析框架--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--日志生成框架--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--自定义Maven项目编译器compiler插件相关配置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--自定义Maven项目汇编assembly插件相关配置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">archive</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br>                        <span class="hljs-comment">&lt;!--此处设置成主类的全名--&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com.tomandersen.appclient.AppMain<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">archive</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="更多详细内容可以查阅《Maven实战》"><a href="#更多详细内容可以查阅《Maven实战》" class="headerlink" title="更多详细内容可以查阅《Maven实战》"></a>更多详细内容可以查阅《Maven实战》</h2><hr><h2 id="End"><a href="#End" class="headerlink" title="End~"></a>End~</h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
    
      <category term="Maven" scheme="https://tomandersen-cc.github.io/categories/Maven/"/>
    
    
      <category term="Maven" scheme="https://tomandersen-cc.github.io/tags/Maven/"/>
    
      <category term="XML" scheme="https://tomandersen-cc.github.io/tags/XML/"/>
    
  </entry>
  
</feed>
